{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robingame docs Object-oriented tools for PyGame projects :)","title":"Robingame docs"},{"location":"#robingame-docs","text":"Object-oriented tools for PyGame projects :)","title":"Robingame docs"},{"location":"quickstart/","text":"Quick start import foo foo()","title":"Quick start"},{"location":"quickstart/#quick-start","text":"import foo foo()","title":"Quick start"},{"location":"reference/image/sprite_animation/","text":"SpriteAnimation Animates a sequence of images. Can scale, flip, and recolor itself. Source code in robingame/image/sprite_animation.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 class SpriteAnimation : \"\"\" Animates a sequence of images. Can scale, flip, and recolor itself. \"\"\" images : list [ Surface ] | None def __init__ ( self , images : list [ Surface ] = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict [ Color : Color ] = None , ): \"\"\" Args: images: a list of Surfaces to use as frames scale: factor by which to scale images flip_x: flip all images horizontally if True flip_y: flip all images vertically if True colormap: used to recolor a sprite. It is a mapping of old colours to new colours \"\"\" self . images = images if scale : self . scale ( scale ) if flip_x or flip_y : self . flip ( flip_x , flip_y ) if colormap : self . recolor ( colormap ) @classmethod def from_image ( cls , filename : Path | str , colorkey = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load the SpriteAnimation from a single image. Alias for `from_spritesheet`. \"\"\" return cls . from_spritesheet ( filename = filename , image_size = None , colorkey = colorkey , flip_x = flip_x , flip_y = flip_y , colormap = colormap , scale = scale , ) @classmethod def from_spritesheet ( cls , filename : Path | str , image_size : ( int , int ), colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a spritesheet. \"\"\" images = load_spritesheet ( filename = filename , image_size = image_size , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) @classmethod def from_image_sequence ( cls , filename : Path | str , colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a sequence of images in a folder. \"\"\" images = load_image_sequence ( filename = filename , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) ############## playback ############### def play ( self , n : int ) -> Surface | bool : \"\"\" Fetch frame with index `n`. This is used in the game loop (where `n` is the iteration counter) to animate the sprite. Return False when we've run out of frames. Args: n: Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return False def loop ( self , n : int ) -> Surface : \"\"\" Like `play()` but if `n` is greater than the number of frames, start again at the beginning. Args: n: Returns: the frame to display \"\"\" return self . play ( n % len ( self . images )) def play_once ( self , n : int , repeat_frame : int = - 1 ) -> Surface : \"\"\" Run the animation once and then continue returning the specified frame (default=last frame). Args: n: repeat_frame: the frame to repeat after the animation has finished (default = last frame) Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return self . images [ repeat_frame ] ############## edit in place ############### def flip ( self , flip_x : bool , flip_y : bool ): \"\"\" Flip in place. Args: flip_x: flip horizontally flip_y: flip vertically \"\"\" self . images = flip_images ( self . images , flip_x , flip_y ) def recolor ( self , colormap : dict ): \"\"\" Recolor in place. Args: colormap: mapping of old colours to new colours \"\"\" self . images = recolor_images ( self . images , colormap ) def scale ( self , scale : float ): \"\"\" Scale in place. Args: scale: factor by which to scale images \"\"\" self . images = scale_images ( self . images , scale ) ############## edit and copy ############### def flipped_copy ( self , flip_x = False , flip_y = False ) -> \"SpriteAnimation\" : \"\"\" Like `flip()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = flip_images ( self . images , flip_x , flip_y )) def recolored_copy ( self , colormap : dict ) -> \"SpriteAnimation\" : \"\"\" Like `recolor()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = recolor_images ( self . images , colormap )) def scaled_copy ( self , scale : float ) -> \"SpriteAnimation\" : \"\"\" Like `scale()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = scale_images ( self . images , scale )) def __len__ ( self ): return len ( self . images ) __init__ ( images = None , scale = None , flip_x = False , flip_y = False , colormap = None ) Parameters: images ( list [ Surface ] ) \u2013 a list of Surfaces to use as frames scale ( float ) \u2013 factor by which to scale images flip_x ( bool ) \u2013 flip all images horizontally if True flip_y ( bool ) \u2013 flip all images vertically if True colormap ( dict [ Color : Color ] ) \u2013 used to recolor a sprite. It is a mapping of old colours to new colours robingame/image/sprite_animation.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self , images : list [ Surface ] = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict [ Color : Color ] = None , ): \"\"\" Args: images: a list of Surfaces to use as frames scale: factor by which to scale images flip_x: flip all images horizontally if True flip_y: flip all images vertically if True colormap: used to recolor a sprite. It is a mapping of old colours to new colours \"\"\" self . images = images if scale : self . scale ( scale ) if flip_x or flip_y : self . flip ( flip_x , flip_y ) if colormap : self . recolor ( colormap ) flip ( flip_x , flip_y ) Flip in place. Parameters: flip_x ( bool ) \u2013 flip horizontally flip_y ( bool ) \u2013 flip vertically robingame/image/sprite_animation.py 156 157 158 159 160 161 162 163 164 def flip ( self , flip_x : bool , flip_y : bool ): \"\"\" Flip in place. Args: flip_x: flip horizontally flip_y: flip vertically \"\"\" self . images = flip_images ( self . images , flip_x , flip_y ) flipped_copy ( flip_x = False , flip_y = False ) Like flip() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 185 186 187 188 189 190 191 192 def flipped_copy ( self , flip_x = False , flip_y = False ) -> \"SpriteAnimation\" : \"\"\" Like `flip()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = flip_images ( self . images , flip_x , flip_y )) from_image ( filename , colorkey = None , scale = None , flip_x = False , flip_y = False , colormap = None ) classmethod Load the SpriteAnimation from a single image. Alias for from_spritesheet . robingame/image/sprite_animation.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @classmethod def from_image ( cls , filename : Path | str , colorkey = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load the SpriteAnimation from a single image. Alias for `from_spritesheet`. \"\"\" return cls . from_spritesheet ( filename = filename , image_size = None , colorkey = colorkey , flip_x = flip_x , flip_y = flip_y , colormap = colormap , scale = scale , ) from_image_sequence ( filename , colorkey = None , num_images = 0 , scale = None , flip_x = False , flip_y = False , colormap = None ) classmethod Load a SpriteAnimation from a sequence of images in a folder. robingame/image/sprite_animation.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @classmethod def from_image_sequence ( cls , filename : Path | str , colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a sequence of images in a folder. \"\"\" images = load_image_sequence ( filename = filename , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) from_spritesheet ( filename , image_size , colorkey = None , num_images = 0 , scale = None , flip_x = False , flip_y = False , colormap = None ) classmethod Load a SpriteAnimation from a spritesheet. robingame/image/sprite_animation.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @classmethod def from_spritesheet ( cls , filename : Path | str , image_size : ( int , int ), colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a spritesheet. \"\"\" images = load_spritesheet ( filename = filename , image_size = image_size , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) loop ( n ) Like play() but if n is greater than the number of frames, start again at the beginning. Parameters: n ( int ) \u2013 Returns: Surface \u2013 the frame to display robingame/image/sprite_animation.py 125 126 127 128 129 130 131 132 133 134 135 def loop ( self , n : int ) -> Surface : \"\"\" Like `play()` but if `n` is greater than the number of frames, start again at the beginning. Args: n: Returns: the frame to display \"\"\" return self . play ( n % len ( self . images )) play ( n ) Fetch frame with index n . This is used in the game loop (where n is the iteration counter) to animate the sprite. Return False when we've run out of frames. Parameters: n ( int ) \u2013 Returns: Surface | bool \u2013 the frame to display robingame/image/sprite_animation.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def play ( self , n : int ) -> Surface | bool : \"\"\" Fetch frame with index `n`. This is used in the game loop (where `n` is the iteration counter) to animate the sprite. Return False when we've run out of frames. Args: n: Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return False play_once ( n , repeat_frame =- 1 ) Run the animation once and then continue returning the specified frame (default=last frame). Parameters: n ( int ) \u2013 repeat_frame ( int ) \u2013 the frame to repeat after the animation has finished (default = last frame) Returns: Surface \u2013 the frame to display robingame/image/sprite_animation.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def play_once ( self , n : int , repeat_frame : int = - 1 ) -> Surface : \"\"\" Run the animation once and then continue returning the specified frame (default=last frame). Args: n: repeat_frame: the frame to repeat after the animation has finished (default = last frame) Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return self . images [ repeat_frame ] recolor ( colormap ) Recolor in place. Parameters: colormap ( dict ) \u2013 mapping of old colours to new colours robingame/image/sprite_animation.py 166 167 168 169 170 171 172 173 def recolor ( self , colormap : dict ): \"\"\" Recolor in place. Args: colormap: mapping of old colours to new colours \"\"\" self . images = recolor_images ( self . images , colormap ) recolored_copy ( colormap ) Like recolor() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 194 195 196 197 198 199 200 201 def recolored_copy ( self , colormap : dict ) -> \"SpriteAnimation\" : \"\"\" Like `recolor()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = recolor_images ( self . images , colormap )) scale ( scale ) Scale in place. Parameters: scale ( float ) \u2013 factor by which to scale images robingame/image/sprite_animation.py 175 176 177 178 179 180 181 182 def scale ( self , scale : float ): \"\"\" Scale in place. Args: scale: factor by which to scale images \"\"\" self . images = scale_images ( self . images , scale ) scaled_copy ( scale ) Like scale() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 203 204 205 206 207 208 209 210 def scaled_copy ( self , scale : float ) -> \"SpriteAnimation\" : \"\"\" Like `scale()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = scale_images ( self . images , scale ))","title":"SpriteAnimation"},{"location":"reference/image/sprite_animation/#spriteanimation","text":"Animates a sequence of images. Can scale, flip, and recolor itself. Source code in robingame/image/sprite_animation.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 class SpriteAnimation : \"\"\" Animates a sequence of images. Can scale, flip, and recolor itself. \"\"\" images : list [ Surface ] | None def __init__ ( self , images : list [ Surface ] = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict [ Color : Color ] = None , ): \"\"\" Args: images: a list of Surfaces to use as frames scale: factor by which to scale images flip_x: flip all images horizontally if True flip_y: flip all images vertically if True colormap: used to recolor a sprite. It is a mapping of old colours to new colours \"\"\" self . images = images if scale : self . scale ( scale ) if flip_x or flip_y : self . flip ( flip_x , flip_y ) if colormap : self . recolor ( colormap ) @classmethod def from_image ( cls , filename : Path | str , colorkey = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load the SpriteAnimation from a single image. Alias for `from_spritesheet`. \"\"\" return cls . from_spritesheet ( filename = filename , image_size = None , colorkey = colorkey , flip_x = flip_x , flip_y = flip_y , colormap = colormap , scale = scale , ) @classmethod def from_spritesheet ( cls , filename : Path | str , image_size : ( int , int ), colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a spritesheet. \"\"\" images = load_spritesheet ( filename = filename , image_size = image_size , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) @classmethod def from_image_sequence ( cls , filename : Path | str , colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a sequence of images in a folder. \"\"\" images = load_image_sequence ( filename = filename , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) ############## playback ############### def play ( self , n : int ) -> Surface | bool : \"\"\" Fetch frame with index `n`. This is used in the game loop (where `n` is the iteration counter) to animate the sprite. Return False when we've run out of frames. Args: n: Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return False def loop ( self , n : int ) -> Surface : \"\"\" Like `play()` but if `n` is greater than the number of frames, start again at the beginning. Args: n: Returns: the frame to display \"\"\" return self . play ( n % len ( self . images )) def play_once ( self , n : int , repeat_frame : int = - 1 ) -> Surface : \"\"\" Run the animation once and then continue returning the specified frame (default=last frame). Args: n: repeat_frame: the frame to repeat after the animation has finished (default = last frame) Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return self . images [ repeat_frame ] ############## edit in place ############### def flip ( self , flip_x : bool , flip_y : bool ): \"\"\" Flip in place. Args: flip_x: flip horizontally flip_y: flip vertically \"\"\" self . images = flip_images ( self . images , flip_x , flip_y ) def recolor ( self , colormap : dict ): \"\"\" Recolor in place. Args: colormap: mapping of old colours to new colours \"\"\" self . images = recolor_images ( self . images , colormap ) def scale ( self , scale : float ): \"\"\" Scale in place. Args: scale: factor by which to scale images \"\"\" self . images = scale_images ( self . images , scale ) ############## edit and copy ############### def flipped_copy ( self , flip_x = False , flip_y = False ) -> \"SpriteAnimation\" : \"\"\" Like `flip()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = flip_images ( self . images , flip_x , flip_y )) def recolored_copy ( self , colormap : dict ) -> \"SpriteAnimation\" : \"\"\" Like `recolor()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = recolor_images ( self . images , colormap )) def scaled_copy ( self , scale : float ) -> \"SpriteAnimation\" : \"\"\" Like `scale()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = scale_images ( self . images , scale )) def __len__ ( self ): return len ( self . images )","title":"SpriteAnimation"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.__init__","text":"Parameters: images ( list [ Surface ] ) \u2013 a list of Surfaces to use as frames scale ( float ) \u2013 factor by which to scale images flip_x ( bool ) \u2013 flip all images horizontally if True flip_y ( bool ) \u2013 flip all images vertically if True colormap ( dict [ Color : Color ] ) \u2013 used to recolor a sprite. It is a mapping of old colours to new colours robingame/image/sprite_animation.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self , images : list [ Surface ] = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict [ Color : Color ] = None , ): \"\"\" Args: images: a list of Surfaces to use as frames scale: factor by which to scale images flip_x: flip all images horizontally if True flip_y: flip all images vertically if True colormap: used to recolor a sprite. It is a mapping of old colours to new colours \"\"\" self . images = images if scale : self . scale ( scale ) if flip_x or flip_y : self . flip ( flip_x , flip_y ) if colormap : self . recolor ( colormap )","title":"__init__()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.flip","text":"Flip in place. Parameters: flip_x ( bool ) \u2013 flip horizontally flip_y ( bool ) \u2013 flip vertically robingame/image/sprite_animation.py 156 157 158 159 160 161 162 163 164 def flip ( self , flip_x : bool , flip_y : bool ): \"\"\" Flip in place. Args: flip_x: flip horizontally flip_y: flip vertically \"\"\" self . images = flip_images ( self . images , flip_x , flip_y )","title":"flip()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.flipped_copy","text":"Like flip() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 185 186 187 188 189 190 191 192 def flipped_copy ( self , flip_x = False , flip_y = False ) -> \"SpriteAnimation\" : \"\"\" Like `flip()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = flip_images ( self . images , flip_x , flip_y ))","title":"flipped_copy()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.from_image","text":"Load the SpriteAnimation from a single image. Alias for from_spritesheet . robingame/image/sprite_animation.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @classmethod def from_image ( cls , filename : Path | str , colorkey = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load the SpriteAnimation from a single image. Alias for `from_spritesheet`. \"\"\" return cls . from_spritesheet ( filename = filename , image_size = None , colorkey = colorkey , flip_x = flip_x , flip_y = flip_y , colormap = colormap , scale = scale , )","title":"from_image()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.from_image_sequence","text":"Load a SpriteAnimation from a sequence of images in a folder. robingame/image/sprite_animation.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @classmethod def from_image_sequence ( cls , filename : Path | str , colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a sequence of images in a folder. \"\"\" images = load_image_sequence ( filename = filename , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap )","title":"from_image_sequence()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.from_spritesheet","text":"Load a SpriteAnimation from a spritesheet. robingame/image/sprite_animation.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @classmethod def from_spritesheet ( cls , filename : Path | str , image_size : ( int , int ), colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a spritesheet. \"\"\" images = load_spritesheet ( filename = filename , image_size = image_size , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap )","title":"from_spritesheet()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.loop","text":"Like play() but if n is greater than the number of frames, start again at the beginning. Parameters: n ( int ) \u2013 Returns: Surface \u2013 the frame to display robingame/image/sprite_animation.py 125 126 127 128 129 130 131 132 133 134 135 def loop ( self , n : int ) -> Surface : \"\"\" Like `play()` but if `n` is greater than the number of frames, start again at the beginning. Args: n: Returns: the frame to display \"\"\" return self . play ( n % len ( self . images ))","title":"loop()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.play","text":"Fetch frame with index n . This is used in the game loop (where n is the iteration counter) to animate the sprite. Return False when we've run out of frames. Parameters: n ( int ) \u2013 Returns: Surface | bool \u2013 the frame to display robingame/image/sprite_animation.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 def play ( self , n : int ) -> Surface | bool : \"\"\" Fetch frame with index `n`. This is used in the game loop (where `n` is the iteration counter) to animate the sprite. Return False when we've run out of frames. Args: n: Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return False","title":"play()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.play_once","text":"Run the animation once and then continue returning the specified frame (default=last frame). Parameters: n ( int ) \u2013 repeat_frame ( int ) \u2013 the frame to repeat after the animation has finished (default = last frame) Returns: Surface \u2013 the frame to display robingame/image/sprite_animation.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def play_once ( self , n : int , repeat_frame : int = - 1 ) -> Surface : \"\"\" Run the animation once and then continue returning the specified frame (default=last frame). Args: n: repeat_frame: the frame to repeat after the animation has finished (default = last frame) Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return self . images [ repeat_frame ]","title":"play_once()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.recolor","text":"Recolor in place. Parameters: colormap ( dict ) \u2013 mapping of old colours to new colours robingame/image/sprite_animation.py 166 167 168 169 170 171 172 173 def recolor ( self , colormap : dict ): \"\"\" Recolor in place. Args: colormap: mapping of old colours to new colours \"\"\" self . images = recolor_images ( self . images , colormap )","title":"recolor()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.recolored_copy","text":"Like recolor() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 194 195 196 197 198 199 200 201 def recolored_copy ( self , colormap : dict ) -> \"SpriteAnimation\" : \"\"\" Like `recolor()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = recolor_images ( self . images , colormap ))","title":"recolored_copy()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.scale","text":"Scale in place. Parameters: scale ( float ) \u2013 factor by which to scale images robingame/image/sprite_animation.py 175 176 177 178 179 180 181 182 def scale ( self , scale : float ): \"\"\" Scale in place. Args: scale: factor by which to scale images \"\"\" self . images = scale_images ( self . images , scale )","title":"scale()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.scaled_copy","text":"Like scale() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 203 204 205 206 207 208 209 210 def scaled_copy ( self , scale : float ) -> \"SpriteAnimation\" : \"\"\" Like `scale()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = scale_images ( self . images , scale ))","title":"scaled_copy()"},{"location":"reference/objects/entity/","text":"Entity Bases: pygame . sprite . Sprite Finite State Machine: self.state is executed every tick self.tick is incremented every time the main game loop executes when self.state changes, self.tick is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: Entities can be added to Groups to create a hierarchical structure The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity Source code in robingame/objects/entity.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Entity ( pygame . sprite . Sprite ): \"\"\" Finite State Machine: - `self.state` is executed every tick - `self.tick` is incremented every time the main game loop executes - when `self.state` changes, `self.tick` is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: - `Entities` can be added to `Groups` to create a hierarchical structure - The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: ``` Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity ``` \"\"\" _state : Callable = lambda * args , ** kwargs : None # default state: do nothing child_groups : list [ Group ] # groups of child Entities belonging to this entity tick : int = 0 # number of game loop iterations elapsed in the current state def __init__ ( self , groups : Iterable [ Group ] = ()): super () . __init__ ( * groups ) self . child_groups = [] def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill () @property def state ( self ): \"\"\"Execute the current state function.\"\"\" return self . _state @state . setter def state ( self , new_state ): \"\"\" Reset self.tick when state changes so we know how long we've been in the current state. \"\"\" self . _state = new_state self . tick = 0 def __repr__ ( self ): # The `_Sprite__g` is necessary because of name mangling in subclasses I think return f \"< { self . __class__ . __name__ } Entity(in { len ( self . _Sprite__g ) } groups)>\" state property writable Execute the current state function. draw ( surface , debug = False ) Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Parameters: surface ( Surface ) \u2013 the surface (usually the screen) on which to draw self debug ( bool ) \u2013 if True, draw extra stuff for debugging robingame/objects/entity.py 65 66 67 68 69 70 71 72 73 74 75 76 def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) kill () Removes self from all groups. robingame/objects/entity.py 78 79 80 81 82 def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill () update () Execute self.state . Call .update() on all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment self.tick to keep track of how long we've been in the current state. robingame/objects/entity.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state","title":"Entity"},{"location":"reference/objects/entity/#entity","text":"Bases: pygame . sprite . Sprite Finite State Machine: self.state is executed every tick self.tick is incremented every time the main game loop executes when self.state changes, self.tick is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: Entities can be added to Groups to create a hierarchical structure The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity Source code in robingame/objects/entity.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Entity ( pygame . sprite . Sprite ): \"\"\" Finite State Machine: - `self.state` is executed every tick - `self.tick` is incremented every time the main game loop executes - when `self.state` changes, `self.tick` is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: - `Entities` can be added to `Groups` to create a hierarchical structure - The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: ``` Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity ``` \"\"\" _state : Callable = lambda * args , ** kwargs : None # default state: do nothing child_groups : list [ Group ] # groups of child Entities belonging to this entity tick : int = 0 # number of game loop iterations elapsed in the current state def __init__ ( self , groups : Iterable [ Group ] = ()): super () . __init__ ( * groups ) self . child_groups = [] def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill () @property def state ( self ): \"\"\"Execute the current state function.\"\"\" return self . _state @state . setter def state ( self , new_state ): \"\"\" Reset self.tick when state changes so we know how long we've been in the current state. \"\"\" self . _state = new_state self . tick = 0 def __repr__ ( self ): # The `_Sprite__g` is necessary because of name mangling in subclasses I think return f \"< { self . __class__ . __name__ } Entity(in { len ( self . _Sprite__g ) } groups)>\"","title":"Entity"},{"location":"reference/objects/entity/#robingame.objects.entity.Entity.state","text":"Execute the current state function.","title":"state"},{"location":"reference/objects/entity/#robingame.objects.entity.Entity.draw","text":"Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Parameters: surface ( Surface ) \u2013 the surface (usually the screen) on which to draw self debug ( bool ) \u2013 if True, draw extra stuff for debugging robingame/objects/entity.py 65 66 67 68 69 70 71 72 73 74 75 76 def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug )","title":"draw()"},{"location":"reference/objects/entity/#robingame.objects.entity.Entity.kill","text":"Removes self from all groups. robingame/objects/entity.py 78 79 80 81 82 def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill ()","title":"kill()"},{"location":"reference/objects/entity/#robingame.objects.entity.Entity.update","text":"Execute self.state . Call .update() on all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment self.tick to keep track of how long we've been in the current state. robingame/objects/entity.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state","title":"update()"},{"location":"reference/objects/game/","text":"Game Example usage: # your_game.py from levels import Level1 # Level1 is an entity class MyGame(Game): def __init__(self): super().__init__() self.children = Group() self.child_groups = [self.children] self.children.add(Level1(...)) if __name__ == \"__main__\": MyGame().main() Bases: Entity Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: initialising the display setting up and running the main game loop. doing clock.tick() every iteration and enforcing the framerate filling the screen with self.screen_color every iteration updating the EventQueue with new events maintaining the FPS tracker (and drawing it in debug mode) Source code in robingame/objects/game.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Game ( Entity ): \"\"\" Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: - initialising the display - setting up and running the main game loop. - doing `clock.tick()` every iteration and enforcing the framerate - filling the screen with `self.screen_color` every iteration - updating the EventQueue with new events - maintaining the FPS tracker (and drawing it in debug mode) \"\"\" fps : int = 60 window_width : int = 500 window_height : int = 500 window_caption : str = \"Game\" screen_color = Color ( \"black\" ) debug : bool = False # draw / print debug info? running : bool # is the main game loop running def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock () def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit () def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass def _update ( self ): \"\"\" 1. read inputs 2. update \"\"\" self . read_inputs () if self . debug : self . print_debug_info () self . update () self . fps_tracker . update () if self . fps : self . clock . tick ( self . fps ) def _draw ( self , surface : Surface , debug : bool = False ): surface . fill ( self . screen_color ) # clear the screen self . draw ( surface , debug ) self . fps_tracker . draw ( surface , debug ) pygame . display . update () # print to screen __init__ () Handles a lot of the boilerplate pygame setup. Creates the display ( self.window ). robingame/objects/game.py 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock () main () Contains the main game loop. Calls self._update() and self._draw() on every iteration of the game loop. robingame/objects/game.py 46 47 48 49 50 51 52 53 54 55 56 def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit () print_debug_info () Override this if you want to print any debug info. robingame/objects/game.py 76 77 78 79 80 def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass read_inputs () Called by self._update() , before super().update() updates the children. Any code that polls external joysticks/controllers should go here. robingame/objects/game.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug","title":"Game"},{"location":"reference/objects/game/#game","text":"Example usage: # your_game.py from levels import Level1 # Level1 is an entity class MyGame(Game): def __init__(self): super().__init__() self.children = Group() self.child_groups = [self.children] self.children.add(Level1(...)) if __name__ == \"__main__\": MyGame().main() Bases: Entity Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: initialising the display setting up and running the main game loop. doing clock.tick() every iteration and enforcing the framerate filling the screen with self.screen_color every iteration updating the EventQueue with new events maintaining the FPS tracker (and drawing it in debug mode) Source code in robingame/objects/game.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Game ( Entity ): \"\"\" Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: - initialising the display - setting up and running the main game loop. - doing `clock.tick()` every iteration and enforcing the framerate - filling the screen with `self.screen_color` every iteration - updating the EventQueue with new events - maintaining the FPS tracker (and drawing it in debug mode) \"\"\" fps : int = 60 window_width : int = 500 window_height : int = 500 window_caption : str = \"Game\" screen_color = Color ( \"black\" ) debug : bool = False # draw / print debug info? running : bool # is the main game loop running def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock () def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit () def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass def _update ( self ): \"\"\" 1. read inputs 2. update \"\"\" self . read_inputs () if self . debug : self . print_debug_info () self . update () self . fps_tracker . update () if self . fps : self . clock . tick ( self . fps ) def _draw ( self , surface : Surface , debug : bool = False ): surface . fill ( self . screen_color ) # clear the screen self . draw ( surface , debug ) self . fps_tracker . draw ( surface , debug ) pygame . display . update () # print to screen","title":"Game"},{"location":"reference/objects/game/#robingame.objects.game.Game.__init__","text":"Handles a lot of the boilerplate pygame setup. Creates the display ( self.window ). robingame/objects/game.py 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock ()","title":"__init__()"},{"location":"reference/objects/game/#robingame.objects.game.Game.main","text":"Contains the main game loop. Calls self._update() and self._draw() on every iteration of the game loop. robingame/objects/game.py 46 47 48 49 50 51 52 53 54 55 56 def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit ()","title":"main()"},{"location":"reference/objects/game/#robingame.objects.game.Game.print_debug_info","text":"Override this if you want to print any debug info. robingame/objects/game.py 76 77 78 79 80 def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass","title":"print_debug_info()"},{"location":"reference/objects/game/#robingame.objects.game.Game.read_inputs","text":"Called by self._update() , before super().update() updates the children. Any code that polls external joysticks/controllers should go here. robingame/objects/game.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug","title":"read_inputs()"},{"location":"reference/objects/group/","text":"Group Bases: pygame . sprite . Group Container for multiple Entities. Source code in robingame/objects/group.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Group ( pygame . sprite . Group ): \"\"\"Container for multiple Entities.\"\"\" def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities ) def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args ) def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = [] def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill () add ( * entities ) Does the same thing as pygame's Group.add() . Only overriding this because pygame's typing was making the linter complain. robingame/objects/group.py 11 12 13 14 15 16 def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities ) draw ( surface , debug = False ) Call .draw(surface, debug) on all member Entities. This is different from pygame's Group.draw() in that it calls the Entity.draw() method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's .image onto the surface. robingame/objects/group.py 24 25 26 27 28 29 30 31 32 33 34 35 def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = [] kill () Call .kill() on all the entities in this group. This is different from Group.empty() . robingame/objects/group.py 37 38 39 40 41 42 43 def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill () update ( * args ) Call .update() on all member Entities. robingame/objects/group.py 18 19 20 21 22 def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args )","title":"Group"},{"location":"reference/objects/group/#group","text":"Bases: pygame . sprite . Group Container for multiple Entities. Source code in robingame/objects/group.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Group ( pygame . sprite . Group ): \"\"\"Container for multiple Entities.\"\"\" def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities ) def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args ) def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = [] def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill ()","title":"Group"},{"location":"reference/objects/group/#robingame.objects.group.Group.add","text":"Does the same thing as pygame's Group.add() . Only overriding this because pygame's typing was making the linter complain. robingame/objects/group.py 11 12 13 14 15 16 def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities )","title":"add()"},{"location":"reference/objects/group/#robingame.objects.group.Group.draw","text":"Call .draw(surface, debug) on all member Entities. This is different from pygame's Group.draw() in that it calls the Entity.draw() method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's .image onto the surface. robingame/objects/group.py 24 25 26 27 28 29 30 31 32 33 34 35 def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = []","title":"draw()"},{"location":"reference/objects/group/#robingame.objects.group.Group.kill","text":"Call .kill() on all the entities in this group. This is different from Group.empty() . robingame/objects/group.py 37 38 39 40 41 42 43 def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill ()","title":"kill()"},{"location":"reference/objects/group/#robingame.objects.group.Group.update","text":"Call .update() on all member Entities. robingame/objects/group.py 18 19 20 21 22 def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args )","title":"update()"},{"location":"reference/text/font/","text":"Font Handles loading custom fonts from a spritesheet, and rendering text onto a surface. Source code in robingame/text/font.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 class Font : \"\"\" Handles loading custom fonts from a spritesheet, and rendering text onto a surface. \"\"\" letters : dict [ str : Surface ] image_size : tuple [ int , int ] xpad : int ypad : int def __init__ ( self , filename : str | Path , image_size : tuple [ int , int ], letters : str , xpad : int = 0 , ypad : int = 0 , trim : bool = False , space_width : int = None , ** kwargs : dict , ): \"\"\" Loads the font from a spritesheet of letters using `load_spritesheet`. Args: filename: path to the spritesheet of letters image_size: the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters: describes the order in which the characters appear in the spritesheet xpad: extra x space between characters (in pixels). Can be negative ypad: extra y space between characters (in pixels). Can be negative trim: if `True`, trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If `False`, leave the characters equal width (results in a monospaced font) space_width: desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs: any extra kwargs will be passed on to `load_spritesheet` Example: ``` test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) ``` \"\"\" self . image_size = width , height = image_size self . xpad = xpad self . ypad = ypad self . letters = dict () self . letters [ \" \" ] = empty_image (( space_width or width , height )) self . not_found = Surface ( image_size ) self . not_found . fill ( Color ( \"red\" )) images = load_spritesheet ( filename , image_size = image_size , ** kwargs ) if trim : images = self . _trim_images ( images ) self . letters . update ({ letter : image for letter , image in zip ( letters , images )}) def render ( self , surf : Surface , text : str , x : int = 0 , y : int = 0 , scale : int = 1 , wrap : int = 0 , align : int = None , ) -> int : \"\"\" Render text onto a surface. Args: surf: surface on which to render the text text: the string of characters to render in this font x: x-position on the surface y: y-position on the surface scale: factor by which to scale the text (1 = no scaling) wrap: x width at which to wrap text align: -1=left, 0=center, 1=right Example: ``` test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) ``` \"\"\" _ , ysize = self . image_size cursor = x for line in text . splitlines (): wrapped_lines = self . _wrap_words ( line , wrap , x , scale ) if wrap else [ line ] for line in wrapped_lines : cursor = self . _align_cursor ( line , x , align , scale , wrap ) for letter in line : image = self . get ( letter ) image = scale_image ( image , scale ) surf . blit ( image , ( cursor , y )) w = image . get_width () cursor += w + self . xpad * scale y += ( ysize + self . ypad ) * scale return cursor def get ( self , letter : str ) -> Surface : \"\"\" Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Args: letter: \"\"\" try : return self . letters [ letter ] except KeyError : return self . not_found def _align_cursor ( self , line : str , x : int , align : int , scale : int , wrap : int ) -> int : \"\"\" Used for left/right/centered text alignmnent \"\"\" match align : case - 1 | None : cursor = x case 0 : if not wrap : raise TextError ( \"Can't center text without specifying a wrap width.\" ) line_width = self . _printed_width ( line , scale ) slack = wrap - line_width cursor = x + slack // 2 case 1 : line_width = self . _printed_width ( line , scale ) cursor = x + wrap - line_width case _ : raise TextError ( f \"Bad alignment value: { align } \" ) return cursor def _wrap_words ( self , text : str , wrap : int , x : int = 0 , scale : int = 1 ) -> list [ str ]: \"\"\" Break one long line into multiple lines based on the wrap width. \"\"\" lines = [] line = \"\" for word in text . split ( \" \" ): new_line = f \" { line } { word } \" if line else word if self . _printed_width ( new_line , scale ) <= wrap : line = new_line else : lines . append ( line ) line = word lines . append ( line ) # last line return lines def _printed_width ( self , text : str , scale : int ) -> int : \"\"\" Calculate how wide a string of text will be when rendered. \"\"\" return sum (( self . get ( letter ) . get_width () + self . xpad ) * scale for letter in text ) def _trim_images ( self , images : list [ Surface ]) -> list [ Surface ]: \"\"\" Make a monospaced font non-monospaced \"\"\" trimmed = [] for image in images : x , _ , w , _ = image . get_bounding_rect () # trim x to bounding rect _ , y , _ , h = image . get_rect () # maintain original y position of character new = image . subsurface (( x , y , w , h )) trimmed . append ( new ) return trimmed __init__ ( filename , image_size , letters , xpad = 0 , ypad = 0 , trim = False , space_width = None , ** kwargs ) Loads the font from a spritesheet of letters using load_spritesheet . Parameters: filename ( str | Path ) \u2013 path to the spritesheet of letters image_size ( tuple [ int , int ] ) \u2013 the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters ( str ) \u2013 describes the order in which the characters appear in the spritesheet xpad ( int ) \u2013 extra x space between characters (in pixels). Can be negative ypad ( int ) \u2013 extra y space between characters (in pixels). Can be negative trim ( bool ) \u2013 if True , trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If False , leave the characters equal width (results in a monospaced font) space_width ( int ) \u2013 desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs ( dict ) \u2013 any extra kwargs will be passed on to load_spritesheet Example test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) robingame/text/font.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , filename : str | Path , image_size : tuple [ int , int ], letters : str , xpad : int = 0 , ypad : int = 0 , trim : bool = False , space_width : int = None , ** kwargs : dict , ): \"\"\" Loads the font from a spritesheet of letters using `load_spritesheet`. Args: filename: path to the spritesheet of letters image_size: the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters: describes the order in which the characters appear in the spritesheet xpad: extra x space between characters (in pixels). Can be negative ypad: extra y space between characters (in pixels). Can be negative trim: if `True`, trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If `False`, leave the characters equal width (results in a monospaced font) space_width: desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs: any extra kwargs will be passed on to `load_spritesheet` Example: ``` test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) ``` \"\"\" self . image_size = width , height = image_size self . xpad = xpad self . ypad = ypad self . letters = dict () self . letters [ \" \" ] = empty_image (( space_width or width , height )) self . not_found = Surface ( image_size ) self . not_found . fill ( Color ( \"red\" )) images = load_spritesheet ( filename , image_size = image_size , ** kwargs ) if trim : images = self . _trim_images ( images ) self . letters . update ({ letter : image for letter , image in zip ( letters , images )}) get ( letter ) Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Parameters: letter ( str ) \u2013 robingame/text/font.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def get ( self , letter : str ) -> Surface : \"\"\" Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Args: letter: \"\"\" try : return self . letters [ letter ] except KeyError : return self . not_found render ( surf , text , x = 0 , y = 0 , scale = 1 , wrap = 0 , align = None ) Render text onto a surface. Parameters: surf ( Surface ) \u2013 surface on which to render the text text ( str ) \u2013 the string of characters to render in this font x ( int ) \u2013 x-position on the surface y ( int ) \u2013 y-position on the surface scale ( int ) \u2013 factor by which to scale the text (1 = no scaling) wrap ( int ) \u2013 x width at which to wrap text align ( int ) \u2013 -1=left, 0=center, 1=right Example test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) robingame/text/font.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def render ( self , surf : Surface , text : str , x : int = 0 , y : int = 0 , scale : int = 1 , wrap : int = 0 , align : int = None , ) -> int : \"\"\" Render text onto a surface. Args: surf: surface on which to render the text text: the string of characters to render in this font x: x-position on the surface y: y-position on the surface scale: factor by which to scale the text (1 = no scaling) wrap: x width at which to wrap text align: -1=left, 0=center, 1=right Example: ``` test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) ``` \"\"\" _ , ysize = self . image_size cursor = x for line in text . splitlines (): wrapped_lines = self . _wrap_words ( line , wrap , x , scale ) if wrap else [ line ] for line in wrapped_lines : cursor = self . _align_cursor ( line , x , align , scale , wrap ) for letter in line : image = self . get ( letter ) image = scale_image ( image , scale ) surf . blit ( image , ( cursor , y )) w = image . get_width () cursor += w + self . xpad * scale y += ( ysize + self . ypad ) * scale return cursor","title":"Font"},{"location":"reference/text/font/#font","text":"Handles loading custom fonts from a spritesheet, and rendering text onto a surface. Source code in robingame/text/font.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 class Font : \"\"\" Handles loading custom fonts from a spritesheet, and rendering text onto a surface. \"\"\" letters : dict [ str : Surface ] image_size : tuple [ int , int ] xpad : int ypad : int def __init__ ( self , filename : str | Path , image_size : tuple [ int , int ], letters : str , xpad : int = 0 , ypad : int = 0 , trim : bool = False , space_width : int = None , ** kwargs : dict , ): \"\"\" Loads the font from a spritesheet of letters using `load_spritesheet`. Args: filename: path to the spritesheet of letters image_size: the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters: describes the order in which the characters appear in the spritesheet xpad: extra x space between characters (in pixels). Can be negative ypad: extra y space between characters (in pixels). Can be negative trim: if `True`, trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If `False`, leave the characters equal width (results in a monospaced font) space_width: desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs: any extra kwargs will be passed on to `load_spritesheet` Example: ``` test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) ``` \"\"\" self . image_size = width , height = image_size self . xpad = xpad self . ypad = ypad self . letters = dict () self . letters [ \" \" ] = empty_image (( space_width or width , height )) self . not_found = Surface ( image_size ) self . not_found . fill ( Color ( \"red\" )) images = load_spritesheet ( filename , image_size = image_size , ** kwargs ) if trim : images = self . _trim_images ( images ) self . letters . update ({ letter : image for letter , image in zip ( letters , images )}) def render ( self , surf : Surface , text : str , x : int = 0 , y : int = 0 , scale : int = 1 , wrap : int = 0 , align : int = None , ) -> int : \"\"\" Render text onto a surface. Args: surf: surface on which to render the text text: the string of characters to render in this font x: x-position on the surface y: y-position on the surface scale: factor by which to scale the text (1 = no scaling) wrap: x width at which to wrap text align: -1=left, 0=center, 1=right Example: ``` test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) ``` \"\"\" _ , ysize = self . image_size cursor = x for line in text . splitlines (): wrapped_lines = self . _wrap_words ( line , wrap , x , scale ) if wrap else [ line ] for line in wrapped_lines : cursor = self . _align_cursor ( line , x , align , scale , wrap ) for letter in line : image = self . get ( letter ) image = scale_image ( image , scale ) surf . blit ( image , ( cursor , y )) w = image . get_width () cursor += w + self . xpad * scale y += ( ysize + self . ypad ) * scale return cursor def get ( self , letter : str ) -> Surface : \"\"\" Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Args: letter: \"\"\" try : return self . letters [ letter ] except KeyError : return self . not_found def _align_cursor ( self , line : str , x : int , align : int , scale : int , wrap : int ) -> int : \"\"\" Used for left/right/centered text alignmnent \"\"\" match align : case - 1 | None : cursor = x case 0 : if not wrap : raise TextError ( \"Can't center text without specifying a wrap width.\" ) line_width = self . _printed_width ( line , scale ) slack = wrap - line_width cursor = x + slack // 2 case 1 : line_width = self . _printed_width ( line , scale ) cursor = x + wrap - line_width case _ : raise TextError ( f \"Bad alignment value: { align } \" ) return cursor def _wrap_words ( self , text : str , wrap : int , x : int = 0 , scale : int = 1 ) -> list [ str ]: \"\"\" Break one long line into multiple lines based on the wrap width. \"\"\" lines = [] line = \"\" for word in text . split ( \" \" ): new_line = f \" { line } { word } \" if line else word if self . _printed_width ( new_line , scale ) <= wrap : line = new_line else : lines . append ( line ) line = word lines . append ( line ) # last line return lines def _printed_width ( self , text : str , scale : int ) -> int : \"\"\" Calculate how wide a string of text will be when rendered. \"\"\" return sum (( self . get ( letter ) . get_width () + self . xpad ) * scale for letter in text ) def _trim_images ( self , images : list [ Surface ]) -> list [ Surface ]: \"\"\" Make a monospaced font non-monospaced \"\"\" trimmed = [] for image in images : x , _ , w , _ = image . get_bounding_rect () # trim x to bounding rect _ , y , _ , h = image . get_rect () # maintain original y position of character new = image . subsurface (( x , y , w , h )) trimmed . append ( new ) return trimmed","title":"Font"},{"location":"reference/text/font/#robingame.text.font.Font.__init__","text":"Loads the font from a spritesheet of letters using load_spritesheet . Parameters: filename ( str | Path ) \u2013 path to the spritesheet of letters image_size ( tuple [ int , int ] ) \u2013 the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters ( str ) \u2013 describes the order in which the characters appear in the spritesheet xpad ( int ) \u2013 extra x space between characters (in pixels). Can be negative ypad ( int ) \u2013 extra y space between characters (in pixels). Can be negative trim ( bool ) \u2013 if True , trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If False , leave the characters equal width (results in a monospaced font) space_width ( int ) \u2013 desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs ( dict ) \u2013 any extra kwargs will be passed on to load_spritesheet Example test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) robingame/text/font.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , filename : str | Path , image_size : tuple [ int , int ], letters : str , xpad : int = 0 , ypad : int = 0 , trim : bool = False , space_width : int = None , ** kwargs : dict , ): \"\"\" Loads the font from a spritesheet of letters using `load_spritesheet`. Args: filename: path to the spritesheet of letters image_size: the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters: describes the order in which the characters appear in the spritesheet xpad: extra x space between characters (in pixels). Can be negative ypad: extra y space between characters (in pixels). Can be negative trim: if `True`, trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If `False`, leave the characters equal width (results in a monospaced font) space_width: desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs: any extra kwargs will be passed on to `load_spritesheet` Example: ``` test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) ``` \"\"\" self . image_size = width , height = image_size self . xpad = xpad self . ypad = ypad self . letters = dict () self . letters [ \" \" ] = empty_image (( space_width or width , height )) self . not_found = Surface ( image_size ) self . not_found . fill ( Color ( \"red\" )) images = load_spritesheet ( filename , image_size = image_size , ** kwargs ) if trim : images = self . _trim_images ( images ) self . letters . update ({ letter : image for letter , image in zip ( letters , images )})","title":"__init__()"},{"location":"reference/text/font/#robingame.text.font.Font.get","text":"Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Parameters: letter ( str ) \u2013 robingame/text/font.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def get ( self , letter : str ) -> Surface : \"\"\" Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Args: letter: \"\"\" try : return self . letters [ letter ] except KeyError : return self . not_found","title":"get()"},{"location":"reference/text/font/#robingame.text.font.Font.render","text":"Render text onto a surface. Parameters: surf ( Surface ) \u2013 surface on which to render the text text ( str ) \u2013 the string of characters to render in this font x ( int ) \u2013 x-position on the surface y ( int ) \u2013 y-position on the surface scale ( int ) \u2013 factor by which to scale the text (1 = no scaling) wrap ( int ) \u2013 x width at which to wrap text align ( int ) \u2013 -1=left, 0=center, 1=right Example test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) robingame/text/font.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def render ( self , surf : Surface , text : str , x : int = 0 , y : int = 0 , scale : int = 1 , wrap : int = 0 , align : int = None , ) -> int : \"\"\" Render text onto a surface. Args: surf: surface on which to render the text text: the string of characters to render in this font x: x-position on the surface y: y-position on the surface scale: factor by which to scale the text (1 = no scaling) wrap: x width at which to wrap text align: -1=left, 0=center, 1=right Example: ``` test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) ``` \"\"\" _ , ysize = self . image_size cursor = x for line in text . splitlines (): wrapped_lines = self . _wrap_words ( line , wrap , x , scale ) if wrap else [ line ] for line in wrapped_lines : cursor = self . _align_cursor ( line , x , align , scale , wrap ) for letter in line : image = self . get ( letter ) image = scale_image ( image , scale ) surf . blit ( image , ( cursor , y )) w = image . get_width () cursor += w + self . xpad * scale y += ( ysize + self . ypad ) * scale return cursor","title":"render()"}]}