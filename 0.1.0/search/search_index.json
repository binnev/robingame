{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robingame docs Object-oriented tools for PyGame projects :)","title":"Robingame docs"},{"location":"#robingame-docs","text":"Object-oriented tools for PyGame projects :)","title":"Robingame docs"},{"location":"quickstart/","text":"Quick start import foo foo()","title":"Quick start"},{"location":"quickstart/#quick-start","text":"import foo foo()","title":"Quick start"},{"location":"reference/entity/","text":"Entity Bases: pygame . sprite . Sprite Finite State Machine: self.state is executed every tick self.tick is incremented every time the main game loop executes when self.state changes, self.tick is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: Entities can be added to Groups to create a hierarchical structure The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity Source code in robingame/objects/entity.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Entity ( pygame . sprite . Sprite ): \"\"\" Finite State Machine: - `self.state` is executed every tick - `self.tick` is incremented every time the main game loop executes - when `self.state` changes, `self.tick` is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: - `Entities` can be added to `Groups` to create a hierarchical structure - The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: ``` Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity ``` \"\"\" _state : Callable = lambda * args , ** kwargs : None # default state: do nothing child_groups : list [ Group ] # groups of child Entities belonging to this entity tick : int = 0 # number of game loop iterations elapsed in the current state def __init__ ( self , groups : Iterable [ Group ] = ()): super () . __init__ ( * groups ) self . child_groups = [] def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill () @property def state ( self ): \"\"\"Execute the current state function.\"\"\" return self . _state @state . setter def state ( self , new_state ): \"\"\" Reset self.tick when state changes so we know how long we've been in the current state. \"\"\" self . _state = new_state self . tick = 0 def __repr__ ( self ): # The `_Sprite__g` is necessary because of name mangling in subclasses I think return f \"< { self . __class__ . __name__ } Entity(in { len ( self . _Sprite__g ) } groups)>\" state property writable Execute the current state function. draw ( surface , debug = False ) Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Parameters: surface ( Surface ) \u2013 the surface (usually the screen) on which to draw self debug ( bool ) \u2013 if True, draw extra stuff for debugging robingame/objects/entity.py 65 66 67 68 69 70 71 72 73 74 75 76 def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) kill () Removes self from all groups. robingame/objects/entity.py 78 79 80 81 82 def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill () update () Execute self.state . Call .update() on all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment self.tick to keep track of how long we've been in the current state. robingame/objects/entity.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state","title":"Entity"},{"location":"reference/entity/#entity","text":"Bases: pygame . sprite . Sprite Finite State Machine: self.state is executed every tick self.tick is incremented every time the main game loop executes when self.state changes, self.tick is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: Entities can be added to Groups to create a hierarchical structure The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity Source code in robingame/objects/entity.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Entity ( pygame . sprite . Sprite ): \"\"\" Finite State Machine: - `self.state` is executed every tick - `self.tick` is incremented every time the main game loop executes - when `self.state` changes, `self.tick` is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: - `Entities` can be added to `Groups` to create a hierarchical structure - The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: ``` Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity ``` \"\"\" _state : Callable = lambda * args , ** kwargs : None # default state: do nothing child_groups : list [ Group ] # groups of child Entities belonging to this entity tick : int = 0 # number of game loop iterations elapsed in the current state def __init__ ( self , groups : Iterable [ Group ] = ()): super () . __init__ ( * groups ) self . child_groups = [] def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill () @property def state ( self ): \"\"\"Execute the current state function.\"\"\" return self . _state @state . setter def state ( self , new_state ): \"\"\" Reset self.tick when state changes so we know how long we've been in the current state. \"\"\" self . _state = new_state self . tick = 0 def __repr__ ( self ): # The `_Sprite__g` is necessary because of name mangling in subclasses I think return f \"< { self . __class__ . __name__ } Entity(in { len ( self . _Sprite__g ) } groups)>\"","title":"Entity"},{"location":"reference/entity/#robingame.objects.entity.Entity.state","text":"Execute the current state function.","title":"state"},{"location":"reference/entity/#robingame.objects.entity.Entity.draw","text":"Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Parameters: surface ( Surface ) \u2013 the surface (usually the screen) on which to draw self debug ( bool ) \u2013 if True, draw extra stuff for debugging robingame/objects/entity.py 65 66 67 68 69 70 71 72 73 74 75 76 def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug )","title":"draw()"},{"location":"reference/entity/#robingame.objects.entity.Entity.kill","text":"Removes self from all groups. robingame/objects/entity.py 78 79 80 81 82 def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill ()","title":"kill()"},{"location":"reference/entity/#robingame.objects.entity.Entity.update","text":"Execute self.state . Call .update() on all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment self.tick to keep track of how long we've been in the current state. robingame/objects/entity.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state","title":"update()"},{"location":"reference/game/","text":"Game Example usage: # your_game.py from levels import Level1 # Level1 is an entity class MyGame(Game): def __init__(self): super().__init__() self.children = Group() self.child_groups = [self.children] self.children.add(Level1(...)) if __name__ == \"__main__\": MyGame().main() Bases: Entity Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: initialising the display setting up and running the main game loop. doing clock.tick() every iteration and enforcing the framerate filling the screen with self.screen_color every iteration updating the EventQueue with new events maintaining the FPS tracker (and drawing it in debug mode) Source code in robingame/objects/game.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Game ( Entity ): \"\"\" Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: - initialising the display - setting up and running the main game loop. - doing `clock.tick()` every iteration and enforcing the framerate - filling the screen with `self.screen_color` every iteration - updating the EventQueue with new events - maintaining the FPS tracker (and drawing it in debug mode) \"\"\" fps : int = 60 window_width : int = 500 window_height : int = 500 window_caption : str = \"Game\" screen_color = Color ( \"black\" ) debug : bool = False # draw / print debug info? running : bool # is the main game loop running def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock () def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit () def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass def _update ( self ): \"\"\" 1. read inputs 2. update \"\"\" self . read_inputs () if self . debug : self . print_debug_info () self . update () self . fps_tracker . update () if self . fps : self . clock . tick ( self . fps ) def _draw ( self , surface : Surface , debug : bool = False ): surface . fill ( self . screen_color ) # clear the screen self . draw ( surface , debug ) self . fps_tracker . draw ( surface , debug ) pygame . display . update () # print to screen __init__ () Handles a lot of the boilerplate pygame setup. Creates the display ( self.window ). robingame/objects/game.py 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock () main () Contains the main game loop. Calls self._update() and self._draw() on every iteration of the game loop. robingame/objects/game.py 46 47 48 49 50 51 52 53 54 55 56 def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit () print_debug_info () Override this if you want to print any debug info. robingame/objects/game.py 76 77 78 79 80 def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass read_inputs () Called by self._update() , before super().update() updates the children. Any code that polls external joysticks/controllers should go here. robingame/objects/game.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug","title":"Game"},{"location":"reference/game/#game","text":"Example usage: # your_game.py from levels import Level1 # Level1 is an entity class MyGame(Game): def __init__(self): super().__init__() self.children = Group() self.child_groups = [self.children] self.children.add(Level1(...)) if __name__ == \"__main__\": MyGame().main() Bases: Entity Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: initialising the display setting up and running the main game loop. doing clock.tick() every iteration and enforcing the framerate filling the screen with self.screen_color every iteration updating the EventQueue with new events maintaining the FPS tracker (and drawing it in debug mode) Source code in robingame/objects/game.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Game ( Entity ): \"\"\" Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: - initialising the display - setting up and running the main game loop. - doing `clock.tick()` every iteration and enforcing the framerate - filling the screen with `self.screen_color` every iteration - updating the EventQueue with new events - maintaining the FPS tracker (and drawing it in debug mode) \"\"\" fps : int = 60 window_width : int = 500 window_height : int = 500 window_caption : str = \"Game\" screen_color = Color ( \"black\" ) debug : bool = False # draw / print debug info? running : bool # is the main game loop running def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock () def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit () def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass def _update ( self ): \"\"\" 1. read inputs 2. update \"\"\" self . read_inputs () if self . debug : self . print_debug_info () self . update () self . fps_tracker . update () if self . fps : self . clock . tick ( self . fps ) def _draw ( self , surface : Surface , debug : bool = False ): surface . fill ( self . screen_color ) # clear the screen self . draw ( surface , debug ) self . fps_tracker . draw ( surface , debug ) pygame . display . update () # print to screen","title":"Game"},{"location":"reference/game/#robingame.objects.game.Game.__init__","text":"Handles a lot of the boilerplate pygame setup. Creates the display ( self.window ). robingame/objects/game.py 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock ()","title":"__init__()"},{"location":"reference/game/#robingame.objects.game.Game.main","text":"Contains the main game loop. Calls self._update() and self._draw() on every iteration of the game loop. robingame/objects/game.py 46 47 48 49 50 51 52 53 54 55 56 def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit ()","title":"main()"},{"location":"reference/game/#robingame.objects.game.Game.print_debug_info","text":"Override this if you want to print any debug info. robingame/objects/game.py 76 77 78 79 80 def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass","title":"print_debug_info()"},{"location":"reference/game/#robingame.objects.game.Game.read_inputs","text":"Called by self._update() , before super().update() updates the children. Any code that polls external joysticks/controllers should go here. robingame/objects/game.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug","title":"read_inputs()"},{"location":"reference/group/","text":"Group Bases: pygame . sprite . Group Container for multiple Entities. Source code in robingame/objects/group.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Group ( pygame . sprite . Group ): \"\"\"Container for multiple Entities.\"\"\" def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities ) def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args ) def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = [] def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill () add ( * entities ) Does the same thing as pygame's Group.add() . Only overriding this because pygame's typing was making the linter complain. robingame/objects/group.py 11 12 13 14 15 16 def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities ) draw ( surface , debug = False ) Call .draw(surface, debug) on all member Entities. This is different from pygame's Group.draw() in that it calls the Entity.draw() method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's .image onto the surface. robingame/objects/group.py 24 25 26 27 28 29 30 31 32 33 34 35 def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = [] kill () Call .kill() on all the entities in this group. This is different from Group.empty() . robingame/objects/group.py 37 38 39 40 41 42 43 def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill () update ( * args ) Call .update() on all member Entities. robingame/objects/group.py 18 19 20 21 22 def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args )","title":"Group"},{"location":"reference/group/#group","text":"Bases: pygame . sprite . Group Container for multiple Entities. Source code in robingame/objects/group.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Group ( pygame . sprite . Group ): \"\"\"Container for multiple Entities.\"\"\" def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities ) def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args ) def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = [] def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill ()","title":"Group"},{"location":"reference/group/#robingame.objects.group.Group.add","text":"Does the same thing as pygame's Group.add() . Only overriding this because pygame's typing was making the linter complain. robingame/objects/group.py 11 12 13 14 15 16 def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities )","title":"add()"},{"location":"reference/group/#robingame.objects.group.Group.draw","text":"Call .draw(surface, debug) on all member Entities. This is different from pygame's Group.draw() in that it calls the Entity.draw() method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's .image onto the surface. robingame/objects/group.py 24 25 26 27 28 29 30 31 32 33 34 35 def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = []","title":"draw()"},{"location":"reference/group/#robingame.objects.group.Group.kill","text":"Call .kill() on all the entities in this group. This is different from Group.empty() . robingame/objects/group.py 37 38 39 40 41 42 43 def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill ()","title":"kill()"},{"location":"reference/group/#robingame.objects.group.Group.update","text":"Call .update() on all member Entities. robingame/objects/group.py 18 19 20 21 22 def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args )","title":"update()"}]}