{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robingame docs Object-oriented tools for PyGame projects :)","title":"Robingame docs"},{"location":"#robingame-docs","text":"Object-oriented tools for PyGame projects :)","title":"Robingame docs"},{"location":"quickstart/","text":"Quick start import foo foo()","title":"Quick start"},{"location":"quickstart/#quick-start","text":"import foo foo()","title":"Quick start"},{"location":"reference/image/sprite_animation/","text":"SpriteAnimation Animates a sequence of images. Can scale, flip, and recolor itself. Source code in robingame/image/sprite_animation.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 class SpriteAnimation : \"\"\" Animates a sequence of images. Can scale, flip, and recolor itself. \"\"\" images : list [ Surface ] | None def __init__ ( self , images : list [ Surface ] = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict [ Color : Color ] = None , ): \"\"\" Args: images: a list of Surfaces to use as frames scale: factor by which to scale images flip_x: flip all images horizontally if True flip_y: flip all images vertically if True colormap: used to recolor a sprite. It is a mapping of old colours to new colours \"\"\" self . images = images if scale : self . scale ( scale ) if flip_x or flip_y : self . flip ( flip_x , flip_y ) if colormap : self . recolor ( colormap ) @classmethod def from_image ( cls , filename : Path | str , colorkey = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load the SpriteAnimation from a single image. Alias for `from_spritesheet`. \"\"\" return cls . from_spritesheet ( filename = filename , image_size = None , colorkey = colorkey , flip_x = flip_x , flip_y = flip_y , colormap = colormap , scale = scale , ) @classmethod def from_spritesheet ( cls , filename : Path | str , image_size : ( int , int ), colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a spritesheet. \"\"\" images = load_spritesheet ( filename = filename , image_size = image_size , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) @classmethod def from_image_sequence ( cls , pattern : Path | str , colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a sequence of images in a folder. Args: pattern: glob pattern used by `load_image_sequence` \"\"\" images = load_image_sequence ( pattern = pattern , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) ############## playback ############### def play ( self , n : int ) -> Surface | bool : \"\"\" Fetch frame with index `n`. This is used in the game loop (where `n` is the iteration counter) to animate the sprite. Return False when we've run out of frames. Args: n: Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return False def loop ( self , n : int ) -> Surface : \"\"\" Like `play()` but if `n` is greater than the number of frames, start again at the beginning. Args: n: Returns: the frame to display \"\"\" return self . play ( n % len ( self . images )) def play_once ( self , n : int , repeat_frame : int = - 1 ) -> Surface : \"\"\" Run the animation once and then continue returning the specified frame (default=last frame). Args: n: repeat_frame: the frame to repeat after the animation has finished (default = last frame) Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return self . images [ repeat_frame ] ############## edit in place ############### def flip ( self , flip_x : bool , flip_y : bool ): \"\"\" Flip in place. Args: flip_x: flip horizontally flip_y: flip vertically \"\"\" self . images = flip_images ( self . images , flip_x , flip_y ) def recolor ( self , colormap : dict ): \"\"\" Recolor in place. Args: colormap: mapping of old colours to new colours \"\"\" self . images = recolor_images ( self . images , colormap ) def scale ( self , scale : float ): \"\"\" Scale in place. Args: scale: factor by which to scale images \"\"\" self . images = scale_images ( self . images , scale ) ############## edit and copy ############### def flipped_copy ( self , flip_x = False , flip_y = False ) -> \"SpriteAnimation\" : \"\"\" Like `flip()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = flip_images ( self . images , flip_x , flip_y )) def recolored_copy ( self , colormap : dict ) -> \"SpriteAnimation\" : \"\"\" Like `recolor()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = recolor_images ( self . images , colormap )) def scaled_copy ( self , scale : float ) -> \"SpriteAnimation\" : \"\"\" Like `scale()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = scale_images ( self . images , scale )) def __len__ ( self ): return len ( self . images ) __init__ ( images = None , scale = None , flip_x = False , flip_y = False , colormap = None ) Parameters: images ( list [ Surface ] ) \u2013 a list of Surfaces to use as frames scale ( float ) \u2013 factor by which to scale images flip_x ( bool ) \u2013 flip all images horizontally if True flip_y ( bool ) \u2013 flip all images vertically if True colormap ( dict [ Color : Color ] ) \u2013 used to recolor a sprite. It is a mapping of old colours to new colours robingame/image/sprite_animation.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self , images : list [ Surface ] = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict [ Color : Color ] = None , ): \"\"\" Args: images: a list of Surfaces to use as frames scale: factor by which to scale images flip_x: flip all images horizontally if True flip_y: flip all images vertically if True colormap: used to recolor a sprite. It is a mapping of old colours to new colours \"\"\" self . images = images if scale : self . scale ( scale ) if flip_x or flip_y : self . flip ( flip_x , flip_y ) if colormap : self . recolor ( colormap ) flip ( flip_x , flip_y ) Flip in place. Parameters: flip_x ( bool ) \u2013 flip horizontally flip_y ( bool ) \u2013 flip vertically robingame/image/sprite_animation.py 159 160 161 162 163 164 165 166 167 def flip ( self , flip_x : bool , flip_y : bool ): \"\"\" Flip in place. Args: flip_x: flip horizontally flip_y: flip vertically \"\"\" self . images = flip_images ( self . images , flip_x , flip_y ) flipped_copy ( flip_x = False , flip_y = False ) Like flip() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 188 189 190 191 192 193 194 195 def flipped_copy ( self , flip_x = False , flip_y = False ) -> \"SpriteAnimation\" : \"\"\" Like `flip()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = flip_images ( self . images , flip_x , flip_y )) from_image ( filename , colorkey = None , scale = None , flip_x = False , flip_y = False , colormap = None ) classmethod Load the SpriteAnimation from a single image. Alias for from_spritesheet . robingame/image/sprite_animation.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @classmethod def from_image ( cls , filename : Path | str , colorkey = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load the SpriteAnimation from a single image. Alias for `from_spritesheet`. \"\"\" return cls . from_spritesheet ( filename = filename , image_size = None , colorkey = colorkey , flip_x = flip_x , flip_y = flip_y , colormap = colormap , scale = scale , ) from_image_sequence ( pattern , colorkey = None , num_images = 0 , scale = None , flip_x = False , flip_y = False , colormap = None ) classmethod Load a SpriteAnimation from a sequence of images in a folder. Parameters: pattern ( Path | str ) \u2013 glob pattern used by load_image_sequence robingame/image/sprite_animation.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @classmethod def from_image_sequence ( cls , pattern : Path | str , colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a sequence of images in a folder. Args: pattern: glob pattern used by `load_image_sequence` \"\"\" images = load_image_sequence ( pattern = pattern , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) from_spritesheet ( filename , image_size , colorkey = None , num_images = 0 , scale = None , flip_x = False , flip_y = False , colormap = None ) classmethod Load a SpriteAnimation from a spritesheet. robingame/image/sprite_animation.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @classmethod def from_spritesheet ( cls , filename : Path | str , image_size : ( int , int ), colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a spritesheet. \"\"\" images = load_spritesheet ( filename = filename , image_size = image_size , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) loop ( n ) Like play() but if n is greater than the number of frames, start again at the beginning. Parameters: n ( int ) \u2013 Returns: Surface \u2013 the frame to display robingame/image/sprite_animation.py 128 129 130 131 132 133 134 135 136 137 138 def loop ( self , n : int ) -> Surface : \"\"\" Like `play()` but if `n` is greater than the number of frames, start again at the beginning. Args: n: Returns: the frame to display \"\"\" return self . play ( n % len ( self . images )) play ( n ) Fetch frame with index n . This is used in the game loop (where n is the iteration counter) to animate the sprite. Return False when we've run out of frames. Parameters: n ( int ) \u2013 Returns: Surface | bool \u2013 the frame to display robingame/image/sprite_animation.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def play ( self , n : int ) -> Surface | bool : \"\"\" Fetch frame with index `n`. This is used in the game loop (where `n` is the iteration counter) to animate the sprite. Return False when we've run out of frames. Args: n: Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return False play_once ( n , repeat_frame =- 1 ) Run the animation once and then continue returning the specified frame (default=last frame). Parameters: n ( int ) \u2013 repeat_frame ( int ) \u2013 the frame to repeat after the animation has finished (default = last frame) Returns: Surface \u2013 the frame to display robingame/image/sprite_animation.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def play_once ( self , n : int , repeat_frame : int = - 1 ) -> Surface : \"\"\" Run the animation once and then continue returning the specified frame (default=last frame). Args: n: repeat_frame: the frame to repeat after the animation has finished (default = last frame) Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return self . images [ repeat_frame ] recolor ( colormap ) Recolor in place. Parameters: colormap ( dict ) \u2013 mapping of old colours to new colours robingame/image/sprite_animation.py 169 170 171 172 173 174 175 176 def recolor ( self , colormap : dict ): \"\"\" Recolor in place. Args: colormap: mapping of old colours to new colours \"\"\" self . images = recolor_images ( self . images , colormap ) recolored_copy ( colormap ) Like recolor() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 197 198 199 200 201 202 203 204 def recolored_copy ( self , colormap : dict ) -> \"SpriteAnimation\" : \"\"\" Like `recolor()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = recolor_images ( self . images , colormap )) scale ( scale ) Scale in place. Parameters: scale ( float ) \u2013 factor by which to scale images robingame/image/sprite_animation.py 178 179 180 181 182 183 184 185 def scale ( self , scale : float ): \"\"\" Scale in place. Args: scale: factor by which to scale images \"\"\" self . images = scale_images ( self . images , scale ) scaled_copy ( scale ) Like scale() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 206 207 208 209 210 211 212 213 def scaled_copy ( self , scale : float ) -> \"SpriteAnimation\" : \"\"\" Like `scale()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = scale_images ( self . images , scale ))","title":"SpriteAnimation"},{"location":"reference/image/sprite_animation/#spriteanimation","text":"Animates a sequence of images. Can scale, flip, and recolor itself. Source code in robingame/image/sprite_animation.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 class SpriteAnimation : \"\"\" Animates a sequence of images. Can scale, flip, and recolor itself. \"\"\" images : list [ Surface ] | None def __init__ ( self , images : list [ Surface ] = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict [ Color : Color ] = None , ): \"\"\" Args: images: a list of Surfaces to use as frames scale: factor by which to scale images flip_x: flip all images horizontally if True flip_y: flip all images vertically if True colormap: used to recolor a sprite. It is a mapping of old colours to new colours \"\"\" self . images = images if scale : self . scale ( scale ) if flip_x or flip_y : self . flip ( flip_x , flip_y ) if colormap : self . recolor ( colormap ) @classmethod def from_image ( cls , filename : Path | str , colorkey = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load the SpriteAnimation from a single image. Alias for `from_spritesheet`. \"\"\" return cls . from_spritesheet ( filename = filename , image_size = None , colorkey = colorkey , flip_x = flip_x , flip_y = flip_y , colormap = colormap , scale = scale , ) @classmethod def from_spritesheet ( cls , filename : Path | str , image_size : ( int , int ), colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a spritesheet. \"\"\" images = load_spritesheet ( filename = filename , image_size = image_size , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) @classmethod def from_image_sequence ( cls , pattern : Path | str , colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a sequence of images in a folder. Args: pattern: glob pattern used by `load_image_sequence` \"\"\" images = load_image_sequence ( pattern = pattern , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap ) ############## playback ############### def play ( self , n : int ) -> Surface | bool : \"\"\" Fetch frame with index `n`. This is used in the game loop (where `n` is the iteration counter) to animate the sprite. Return False when we've run out of frames. Args: n: Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return False def loop ( self , n : int ) -> Surface : \"\"\" Like `play()` but if `n` is greater than the number of frames, start again at the beginning. Args: n: Returns: the frame to display \"\"\" return self . play ( n % len ( self . images )) def play_once ( self , n : int , repeat_frame : int = - 1 ) -> Surface : \"\"\" Run the animation once and then continue returning the specified frame (default=last frame). Args: n: repeat_frame: the frame to repeat after the animation has finished (default = last frame) Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return self . images [ repeat_frame ] ############## edit in place ############### def flip ( self , flip_x : bool , flip_y : bool ): \"\"\" Flip in place. Args: flip_x: flip horizontally flip_y: flip vertically \"\"\" self . images = flip_images ( self . images , flip_x , flip_y ) def recolor ( self , colormap : dict ): \"\"\" Recolor in place. Args: colormap: mapping of old colours to new colours \"\"\" self . images = recolor_images ( self . images , colormap ) def scale ( self , scale : float ): \"\"\" Scale in place. Args: scale: factor by which to scale images \"\"\" self . images = scale_images ( self . images , scale ) ############## edit and copy ############### def flipped_copy ( self , flip_x = False , flip_y = False ) -> \"SpriteAnimation\" : \"\"\" Like `flip()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = flip_images ( self . images , flip_x , flip_y )) def recolored_copy ( self , colormap : dict ) -> \"SpriteAnimation\" : \"\"\" Like `recolor()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = recolor_images ( self . images , colormap )) def scaled_copy ( self , scale : float ) -> \"SpriteAnimation\" : \"\"\" Like `scale()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = scale_images ( self . images , scale )) def __len__ ( self ): return len ( self . images )","title":"SpriteAnimation"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.__init__","text":"Parameters: images ( list [ Surface ] ) \u2013 a list of Surfaces to use as frames scale ( float ) \u2013 factor by which to scale images flip_x ( bool ) \u2013 flip all images horizontally if True flip_y ( bool ) \u2013 flip all images vertically if True colormap ( dict [ Color : Color ] ) \u2013 used to recolor a sprite. It is a mapping of old colours to new colours robingame/image/sprite_animation.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self , images : list [ Surface ] = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict [ Color : Color ] = None , ): \"\"\" Args: images: a list of Surfaces to use as frames scale: factor by which to scale images flip_x: flip all images horizontally if True flip_y: flip all images vertically if True colormap: used to recolor a sprite. It is a mapping of old colours to new colours \"\"\" self . images = images if scale : self . scale ( scale ) if flip_x or flip_y : self . flip ( flip_x , flip_y ) if colormap : self . recolor ( colormap )","title":"__init__()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.flip","text":"Flip in place. Parameters: flip_x ( bool ) \u2013 flip horizontally flip_y ( bool ) \u2013 flip vertically robingame/image/sprite_animation.py 159 160 161 162 163 164 165 166 167 def flip ( self , flip_x : bool , flip_y : bool ): \"\"\" Flip in place. Args: flip_x: flip horizontally flip_y: flip vertically \"\"\" self . images = flip_images ( self . images , flip_x , flip_y )","title":"flip()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.flipped_copy","text":"Like flip() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 188 189 190 191 192 193 194 195 def flipped_copy ( self , flip_x = False , flip_y = False ) -> \"SpriteAnimation\" : \"\"\" Like `flip()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = flip_images ( self . images , flip_x , flip_y ))","title":"flipped_copy()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.from_image","text":"Load the SpriteAnimation from a single image. Alias for from_spritesheet . robingame/image/sprite_animation.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @classmethod def from_image ( cls , filename : Path | str , colorkey = None , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load the SpriteAnimation from a single image. Alias for `from_spritesheet`. \"\"\" return cls . from_spritesheet ( filename = filename , image_size = None , colorkey = colorkey , flip_x = flip_x , flip_y = flip_y , colormap = colormap , scale = scale , )","title":"from_image()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.from_image_sequence","text":"Load a SpriteAnimation from a sequence of images in a folder. Parameters: pattern ( Path | str ) \u2013 glob pattern used by load_image_sequence robingame/image/sprite_animation.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 @classmethod def from_image_sequence ( cls , pattern : Path | str , colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a sequence of images in a folder. Args: pattern: glob pattern used by `load_image_sequence` \"\"\" images = load_image_sequence ( pattern = pattern , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap )","title":"from_image_sequence()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.from_spritesheet","text":"Load a SpriteAnimation from a spritesheet. robingame/image/sprite_animation.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 @classmethod def from_spritesheet ( cls , filename : Path | str , image_size : ( int , int ), colorkey = None , num_images : int = 0 , scale : float = None , flip_x : bool = False , flip_y : bool = False , colormap : dict = None , ) -> \"SpriteAnimation\" : \"\"\" Load a SpriteAnimation from a spritesheet. \"\"\" images = load_spritesheet ( filename = filename , image_size = image_size , colorkey = colorkey , num_images = num_images ) return cls ( images = images , scale = scale , flip_x = flip_x , flip_y = flip_y , colormap = colormap )","title":"from_spritesheet()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.loop","text":"Like play() but if n is greater than the number of frames, start again at the beginning. Parameters: n ( int ) \u2013 Returns: Surface \u2013 the frame to display robingame/image/sprite_animation.py 128 129 130 131 132 133 134 135 136 137 138 def loop ( self , n : int ) -> Surface : \"\"\" Like `play()` but if `n` is greater than the number of frames, start again at the beginning. Args: n: Returns: the frame to display \"\"\" return self . play ( n % len ( self . images ))","title":"loop()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.play","text":"Fetch frame with index n . This is used in the game loop (where n is the iteration counter) to animate the sprite. Return False when we've run out of frames. Parameters: n ( int ) \u2013 Returns: Surface | bool \u2013 the frame to display robingame/image/sprite_animation.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 def play ( self , n : int ) -> Surface | bool : \"\"\" Fetch frame with index `n`. This is used in the game loop (where `n` is the iteration counter) to animate the sprite. Return False when we've run out of frames. Args: n: Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return False","title":"play()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.play_once","text":"Run the animation once and then continue returning the specified frame (default=last frame). Parameters: n ( int ) \u2013 repeat_frame ( int ) \u2013 the frame to repeat after the animation has finished (default = last frame) Returns: Surface \u2013 the frame to display robingame/image/sprite_animation.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 def play_once ( self , n : int , repeat_frame : int = - 1 ) -> Surface : \"\"\" Run the animation once and then continue returning the specified frame (default=last frame). Args: n: repeat_frame: the frame to repeat after the animation has finished (default = last frame) Returns: the frame to display \"\"\" try : return self . images [ n ] except IndexError : return self . images [ repeat_frame ]","title":"play_once()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.recolor","text":"Recolor in place. Parameters: colormap ( dict ) \u2013 mapping of old colours to new colours robingame/image/sprite_animation.py 169 170 171 172 173 174 175 176 def recolor ( self , colormap : dict ): \"\"\" Recolor in place. Args: colormap: mapping of old colours to new colours \"\"\" self . images = recolor_images ( self . images , colormap )","title":"recolor()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.recolored_copy","text":"Like recolor() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 197 198 199 200 201 202 203 204 def recolored_copy ( self , colormap : dict ) -> \"SpriteAnimation\" : \"\"\" Like `recolor()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = recolor_images ( self . images , colormap ))","title":"recolored_copy()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.scale","text":"Scale in place. Parameters: scale ( float ) \u2013 factor by which to scale images robingame/image/sprite_animation.py 178 179 180 181 182 183 184 185 def scale ( self , scale : float ): \"\"\" Scale in place. Args: scale: factor by which to scale images \"\"\" self . images = scale_images ( self . images , scale )","title":"scale()"},{"location":"reference/image/sprite_animation/#robingame.image.sprite_animation.SpriteAnimation.scaled_copy","text":"Like scale() but returns a new instance. Returns: SpriteAnimation \u2013 a new instance robingame/image/sprite_animation.py 206 207 208 209 210 211 212 213 def scaled_copy ( self , scale : float ) -> \"SpriteAnimation\" : \"\"\" Like `scale()` but returns a new instance. Returns: a new instance \"\"\" return self . __class__ ( images = scale_images ( self . images , scale ))","title":"scaled_copy()"},{"location":"reference/image/utils/","text":"Utils brighten ( image , amount ) Use brighten_color to brighten all pixels in an image by amount . Parameters: image ( Surface ) \u2013 the input image amount ( int ) \u2013 how much to increase brightness robingame/image/utils.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def brighten ( image : Surface , amount : int ): \"\"\" Use `brighten_color` to brighten all pixels in an image by `amount`. \\ Args: image: the input image amount: how much to increase brightness \"\"\" width , height = image . get_size () # surface.copy() inherits surface's colorkey; preserving transparency new_image = image . copy () # iterate over all the pixels in the old surface, and write a pixel to the new surface in the # corresponding position. If the colour of the present pixel has an entry in the # color_mapping dict, then write the new colour instead of the old one. for x in range ( width ): for y in range ( height ): color = image . get_at (( x , y ))[:] new_color = brighten_color ( color , amount ) if new_color : new_image . set_at (( x , y ), pygame . Color ( * new_color )) else : new_image . set_at (( x , y ), pygame . Color ( * color )) return new_image brighten_color ( color , amount ) Increase all channels to brighten a colour. Does not allow values greater than 255. Parameters: color ( Color | tuple ) \u2013 the input colour amount ( int ) \u2013 how much to increase each channel Returns: Color \u2013 the output colour robingame/image/utils.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def brighten_color ( color : Color | tuple , amount : int ) -> Color : \"\"\" Increase all channels to brighten a colour. Does not allow values greater than 255. Args: color: the input colour amount: how much to increase each channel Returns: the output colour \"\"\" color = Color ( color ) r = limit_value ( color . r + amount , between = ( 0 , 255 )) g = limit_value ( color . g + amount , between = ( 0 , 255 )) b = limit_value ( color . b + amount , between = ( 0 , 255 )) return Color ( r , g , b , color . a ) empty_image ( * args , ** kwargs ) Generate an empty Surface with .convert_alpha() already called. Returns: Surface \u2013 an empty Surface robingame/image/utils.py 65 66 67 68 69 70 71 72 73 74 def empty_image ( * args , ** kwargs ) -> Surface : \"\"\" Generate an empty Surface with `.convert_alpha()` already called. Returns: an empty Surface \"\"\" img = Surface ( * args , ** kwargs ) . convert_alpha () img . fill (( 0 , 0 , 0 , 0 )) return img flip_image ( image , flip_x = False , flip_y = False ) Return a flipped copy of an image. Parameters: image ( Surface ) \u2013 input image flip_x ( bool ) \u2013 flip horizontally flip_y ( bool ) \u2013 flip vertically Returns: Surface \u2013 output image robingame/image/utils.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def flip_image ( image : Surface , flip_x : bool = False , flip_y : bool = False ) -> Surface : \"\"\" Return a flipped copy of an image. Args: image: input image flip_x: flip horizontally flip_y: flip vertically Returns: output image \"\"\" return pygame . transform . flip ( image , bool ( flip_x ), bool ( flip_y )) flip_images ( images , flip_x = False , flip_y = False ) Apply flip_image to a list of images. robingame/image/utils.py 185 186 187 188 189 def flip_images ( images : [ Surface ], flip_x : bool = False , flip_y : bool = False ): \"\"\" Apply `flip_image` to a list of images. \"\"\" return [ flip_image ( image , flip_x , flip_y ) for image in images ] init_display () Make sure the pygame display is initialised (required for loading images). If the display already exists, return it. If not, generate a new 1x1 pixel display. Returns: Surface \u2013 the pygame display robingame/image/utils.py 11 12 13 14 15 16 17 18 19 20 21 22 23 def init_display () -> Surface : \"\"\" Make sure the pygame display is initialised (required for loading images). If the display already exists, return it. If not, generate a new 1x1 pixel display. Returns: the pygame display \"\"\" if not pygame . display . get_init (): pygame . display . init () return pygame . display . set_mode (( 1 , 1 )) else : return pygame . display . get_surface () load_image ( filename , colorkey = None ) Load an image. Abstracts away some of the pygame pitfalls. Parameters: filename ( str | Path ) \u2013 path to the image file colorkey ( Color | int ) \u2013 sets the color to treat as transparent (like the green in greenscreen). if -1 is passed, then the color of the top-left pixel will be used. Returns: Surface \u2013 the loaded image robingame/image/utils.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def load_image ( filename : str | Path , colorkey : Color | int = None ) -> Surface : \"\"\" Load an image. Abstracts away some of the pygame pitfalls. Args: filename: path to the image file colorkey: sets the color to treat as transparent (like the green in greenscreen). if `-1` is passed, then the color of the top-left pixel will be used. Returns: the loaded image \"\"\" init_display () try : image = pygame . image . load ( filename ) except pygame . error : print ( \"Unable to load image:\" , filename ) raise # colorkey needs to be set before .convert_alpha() is called, because Surfaces with a # per-pixel transparency (i.e. after convert_alpha) ignore colorkey. if colorkey is not None : if colorkey == - 1 : colorkey = image . get_at (( 0 , 0 )) image . set_colorkey ( colorkey , pygame . RLEACCEL ) image = image . convert_alpha () return image load_image_sequence ( pattern , colorkey = None , num_images = 0 ) Load a sequence of images. Parameters: pattern ( Path | str ) \u2013 glob pattern for the image sequence. E.g. if your folder of image contains \"example1.png\", \"example2.png\" , etc, then your pattern should be \"example*.png\" colorkey ( Color ) \u2013 used to recolor images (see load_image ) num_images ( int ) \u2013 used to limit how many images are loaded (default = load all images that match the pattern) Returns: [ Surface ] \u2013 a list of images robingame/image/utils.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def load_image_sequence ( pattern : Path | str , colorkey : Color = None , num_images : int = 0 , ) -> [ Surface ]: \"\"\" Load a sequence of images. Args: pattern: glob pattern for the image sequence. E.g. if your folder of image contains `\"example1.png\", \"example2.png\"`, etc, then your pattern should be `\"example*.png\"` colorkey: used to recolor images (see `load_image`) num_images: used to limit how many images are loaded (default = load all images that match the pattern) Returns: a list of images \"\"\" pattern = Path ( pattern ) . as_posix () files = glob . glob ( pattern ) if not files : raise FileNotFoundError ( f \"Couldn't find any images matching pattern ' { pattern } '\" ) images = [ load_image ( file , colorkey ) for file in files ] if num_images : images = images [: num_images ] return images load_spritesheet ( filename , image_size = None , colorkey = None , num_images = 0 ) Load the image file. Don't call this until pygame.display has been initiated. Split the spritesheet into images and return a list of images. If image_size is None, load the whole spritesheet as one sprite. Parameters: filename ( Path | str ) \u2013 path to the spritesheet file image_size ( int , int ) \u2013 size of the individual frames of the spritesheet (in pixels) colorkey ( Color ) \u2013 used to set transparency (see load_image ) num_images ( int ) \u2013 can be used to limit the number of frames loaded (default = load all) Returns: [ Surface ] \u2013 a list of images robingame/image/utils.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def load_spritesheet ( filename : Path | str , image_size : ( int , int ) = None , colorkey : Color = None , num_images : int = 0 , ) -> [ Surface ]: \"\"\" Load the image file. Don't call this until pygame.display has been initiated. Split the spritesheet into images and return a list of images. If image_size is None, load the whole spritesheet as one sprite. Args: filename: path to the spritesheet file image_size: size of the individual frames of the spritesheet (in pixels) colorkey: used to set transparency (see `load_image`) num_images: can be used to limit the number of frames loaded (default = load all) Returns: a list of images \"\"\" filename = Path ( filename ) if not filename . exists (): raise FileNotFoundError ( f \"Couldn't find { filename } \" ) sheet = load_image ( filename = filename . as_posix (), colorkey = colorkey ) if image_size : width , height = image_size num_horizontal = sheet . get_rect () . width // width num_vertical = sheet . get_rect () . height // height rects = [ pygame . Rect (( width * i , height * j , width , height )) for j in range ( num_vertical ) for i in range ( num_horizontal ) ] images = [ sheet . subsurface ( rect ) for rect in rects ] images = list ( filter ( not_empty , images )) if num_images : images = images [: num_images ] else : images = [ sheet ] return images not_empty ( surface ) Check if a surface has any non-zero pixels. Surface.get_bounding_rect() returns the smallest rectangle on the surface containing data. If the surface is empty, it will return Rect(0, 0, 0, 0), for which any returns False. robingame/image/utils.py 56 57 58 59 60 61 62 def not_empty ( surface : Surface ) -> bool : \"\"\" Check if a surface has any non-zero pixels. `Surface.get_bounding_rect()` returns the smallest rectangle on the surface containing data. If the surface is empty, it will return Rect(0, 0, 0, 0), for which `any` returns False. \"\"\" return any ( surface . get_bounding_rect ()) pad_alpha ( colour_tuple ) Add the 4th (alpha) channel to a length 3 color tuple. By default it sets the new alpha channel to full opacity (255). Parameters: colour_tuple ( Color | tuple ) \u2013 Returns: Color \u2013 a colour robingame/image/utils.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def pad_alpha ( colour_tuple : Color | tuple ) -> Color : \"\"\" Add the 4th (alpha) channel to a length 3 color tuple. By default it sets the new alpha channel to full opacity (255). Args: colour_tuple: Returns: a colour \"\"\" if len ( colour_tuple ) == 3 : # if no alpha channel supplied, assume it's full opacity return ( * colour_tuple , 255 ) elif len ( colour_tuple ) == 4 : return colour_tuple else : raise Exception ( \"bogus colour, man\" ) recolor_image ( surface , color_mapping ) Return a recolored copy of an image. Parameters: surface ( Surface ) \u2013 input image color_mapping ( dict ) \u2013 dictionary of old colors (keys) to new colors (values). Unfortunately they have to be RGB tuples, not pygame Colors, because Color is an unhashable type... Returns: Surface \u2013 output image robingame/image/utils.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def recolor_image ( surface : Surface , color_mapping : dict ) -> Surface : \"\"\" Return a recolored copy of an image. Args: surface: input image color_mapping: dictionary of old colors (keys) to new colors (values). Unfortunately they have to be RGB tuples, not pygame Colors, because Color is an unhashable type... Returns: output image \"\"\" # make sure the colourmap has alpha channel on all colours color_mapping = { pad_alpha ( k ): pad_alpha ( v ) for k , v in color_mapping . items ()} width , height = surface . get_size () # surface.copy() inherits surface's colorkey; preserving transparency new_surface = surface . copy () # iterate over all the pixels in the old surface, and write a pixel to the new surface in the # corresponding position. If the colour of the present pixel has an entry in the # color_mapping dict, then write the new colour instead of the old one. for x in range ( width ): for y in range ( height ): color = surface . get_at (( x , y ))[:] new_color = color_mapping . get ( color ) if new_color : new_surface . set_at (( x , y ), pygame . Color ( * new_color )) else : new_surface . set_at (( x , y ), pygame . Color ( * color )) return new_surface recolor_images ( images , colormap ) Apply recolor_image to a list of images. robingame/image/utils.py 226 227 228 229 230 def recolor_images ( images : [ Surface ], colormap : dict ) -> [ Surface ]: \"\"\" Apply `recolor_image` to a list of images. \"\"\" return [ recolor_image ( image , colormap ) for image in images ] scale_image ( image , scale ) Return a scaled copy of an image. Parameters: image ( Surface ) \u2013 input image scale ( float ) \u2013 factor by which to scale image Returns: Surface \u2013 output image robingame/image/utils.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def scale_image ( image : Surface , scale : float ) -> Surface : \"\"\" Return a scaled copy of an image. Args: image: input image scale: factor by which to scale image Returns: output image \"\"\" width , height = image . get_rect () . size image = pygame . transform . scale ( image , ( width * scale , height * scale )) return image scale_images ( images , scale ) Apply scale_image to a list of images. robingame/image/utils.py 163 164 165 166 167 def scale_images ( images : [ Surface ], scale : float ) -> [ Surface ]: \"\"\" Apply `scale_image` to a list of images. \"\"\" return [ scale_image ( image , scale ) for image in images ]","title":"Utils"},{"location":"reference/image/utils/#utils","text":"","title":"Utils"},{"location":"reference/image/utils/#robingame.image.utils.brighten","text":"Use brighten_color to brighten all pixels in an image by amount . Parameters: image ( Surface ) \u2013 the input image amount ( int ) \u2013 how much to increase brightness robingame/image/utils.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def brighten ( image : Surface , amount : int ): \"\"\" Use `brighten_color` to brighten all pixels in an image by `amount`. \\ Args: image: the input image amount: how much to increase brightness \"\"\" width , height = image . get_size () # surface.copy() inherits surface's colorkey; preserving transparency new_image = image . copy () # iterate over all the pixels in the old surface, and write a pixel to the new surface in the # corresponding position. If the colour of the present pixel has an entry in the # color_mapping dict, then write the new colour instead of the old one. for x in range ( width ): for y in range ( height ): color = image . get_at (( x , y ))[:] new_color = brighten_color ( color , amount ) if new_color : new_image . set_at (( x , y ), pygame . Color ( * new_color )) else : new_image . set_at (( x , y ), pygame . Color ( * color )) return new_image","title":"brighten()"},{"location":"reference/image/utils/#robingame.image.utils.brighten_color","text":"Increase all channels to brighten a colour. Does not allow values greater than 255. Parameters: color ( Color | tuple ) \u2013 the input colour amount ( int ) \u2013 how much to increase each channel Returns: Color \u2013 the output colour robingame/image/utils.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 def brighten_color ( color : Color | tuple , amount : int ) -> Color : \"\"\" Increase all channels to brighten a colour. Does not allow values greater than 255. Args: color: the input colour amount: how much to increase each channel Returns: the output colour \"\"\" color = Color ( color ) r = limit_value ( color . r + amount , between = ( 0 , 255 )) g = limit_value ( color . g + amount , between = ( 0 , 255 )) b = limit_value ( color . b + amount , between = ( 0 , 255 )) return Color ( r , g , b , color . a )","title":"brighten_color()"},{"location":"reference/image/utils/#robingame.image.utils.empty_image","text":"Generate an empty Surface with .convert_alpha() already called. Returns: Surface \u2013 an empty Surface robingame/image/utils.py 65 66 67 68 69 70 71 72 73 74 def empty_image ( * args , ** kwargs ) -> Surface : \"\"\" Generate an empty Surface with `.convert_alpha()` already called. Returns: an empty Surface \"\"\" img = Surface ( * args , ** kwargs ) . convert_alpha () img . fill (( 0 , 0 , 0 , 0 )) return img","title":"empty_image()"},{"location":"reference/image/utils/#robingame.image.utils.flip_image","text":"Return a flipped copy of an image. Parameters: image ( Surface ) \u2013 input image flip_x ( bool ) \u2013 flip horizontally flip_y ( bool ) \u2013 flip vertically Returns: Surface \u2013 output image robingame/image/utils.py 170 171 172 173 174 175 176 177 178 179 180 181 182 def flip_image ( image : Surface , flip_x : bool = False , flip_y : bool = False ) -> Surface : \"\"\" Return a flipped copy of an image. Args: image: input image flip_x: flip horizontally flip_y: flip vertically Returns: output image \"\"\" return pygame . transform . flip ( image , bool ( flip_x ), bool ( flip_y ))","title":"flip_image()"},{"location":"reference/image/utils/#robingame.image.utils.flip_images","text":"Apply flip_image to a list of images. robingame/image/utils.py 185 186 187 188 189 def flip_images ( images : [ Surface ], flip_x : bool = False , flip_y : bool = False ): \"\"\" Apply `flip_image` to a list of images. \"\"\" return [ flip_image ( image , flip_x , flip_y ) for image in images ]","title":"flip_images()"},{"location":"reference/image/utils/#robingame.image.utils.init_display","text":"Make sure the pygame display is initialised (required for loading images). If the display already exists, return it. If not, generate a new 1x1 pixel display. Returns: Surface \u2013 the pygame display robingame/image/utils.py 11 12 13 14 15 16 17 18 19 20 21 22 23 def init_display () -> Surface : \"\"\" Make sure the pygame display is initialised (required for loading images). If the display already exists, return it. If not, generate a new 1x1 pixel display. Returns: the pygame display \"\"\" if not pygame . display . get_init (): pygame . display . init () return pygame . display . set_mode (( 1 , 1 )) else : return pygame . display . get_surface ()","title":"init_display()"},{"location":"reference/image/utils/#robingame.image.utils.load_image","text":"Load an image. Abstracts away some of the pygame pitfalls. Parameters: filename ( str | Path ) \u2013 path to the image file colorkey ( Color | int ) \u2013 sets the color to treat as transparent (like the green in greenscreen). if -1 is passed, then the color of the top-left pixel will be used. Returns: Surface \u2013 the loaded image robingame/image/utils.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def load_image ( filename : str | Path , colorkey : Color | int = None ) -> Surface : \"\"\" Load an image. Abstracts away some of the pygame pitfalls. Args: filename: path to the image file colorkey: sets the color to treat as transparent (like the green in greenscreen). if `-1` is passed, then the color of the top-left pixel will be used. Returns: the loaded image \"\"\" init_display () try : image = pygame . image . load ( filename ) except pygame . error : print ( \"Unable to load image:\" , filename ) raise # colorkey needs to be set before .convert_alpha() is called, because Surfaces with a # per-pixel transparency (i.e. after convert_alpha) ignore colorkey. if colorkey is not None : if colorkey == - 1 : colorkey = image . get_at (( 0 , 0 )) image . set_colorkey ( colorkey , pygame . RLEACCEL ) image = image . convert_alpha () return image","title":"load_image()"},{"location":"reference/image/utils/#robingame.image.utils.load_image_sequence","text":"Load a sequence of images. Parameters: pattern ( Path | str ) \u2013 glob pattern for the image sequence. E.g. if your folder of image contains \"example1.png\", \"example2.png\" , etc, then your pattern should be \"example*.png\" colorkey ( Color ) \u2013 used to recolor images (see load_image ) num_images ( int ) \u2013 used to limit how many images are loaded (default = load all images that match the pattern) Returns: [ Surface ] \u2013 a list of images robingame/image/utils.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def load_image_sequence ( pattern : Path | str , colorkey : Color = None , num_images : int = 0 , ) -> [ Surface ]: \"\"\" Load a sequence of images. Args: pattern: glob pattern for the image sequence. E.g. if your folder of image contains `\"example1.png\", \"example2.png\"`, etc, then your pattern should be `\"example*.png\"` colorkey: used to recolor images (see `load_image`) num_images: used to limit how many images are loaded (default = load all images that match the pattern) Returns: a list of images \"\"\" pattern = Path ( pattern ) . as_posix () files = glob . glob ( pattern ) if not files : raise FileNotFoundError ( f \"Couldn't find any images matching pattern ' { pattern } '\" ) images = [ load_image ( file , colorkey ) for file in files ] if num_images : images = images [: num_images ] return images","title":"load_image_sequence()"},{"location":"reference/image/utils/#robingame.image.utils.load_spritesheet","text":"Load the image file. Don't call this until pygame.display has been initiated. Split the spritesheet into images and return a list of images. If image_size is None, load the whole spritesheet as one sprite. Parameters: filename ( Path | str ) \u2013 path to the spritesheet file image_size ( int , int ) \u2013 size of the individual frames of the spritesheet (in pixels) colorkey ( Color ) \u2013 used to set transparency (see load_image ) num_images ( int ) \u2013 can be used to limit the number of frames loaded (default = load all) Returns: [ Surface ] \u2013 a list of images robingame/image/utils.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 def load_spritesheet ( filename : Path | str , image_size : ( int , int ) = None , colorkey : Color = None , num_images : int = 0 , ) -> [ Surface ]: \"\"\" Load the image file. Don't call this until pygame.display has been initiated. Split the spritesheet into images and return a list of images. If image_size is None, load the whole spritesheet as one sprite. Args: filename: path to the spritesheet file image_size: size of the individual frames of the spritesheet (in pixels) colorkey: used to set transparency (see `load_image`) num_images: can be used to limit the number of frames loaded (default = load all) Returns: a list of images \"\"\" filename = Path ( filename ) if not filename . exists (): raise FileNotFoundError ( f \"Couldn't find { filename } \" ) sheet = load_image ( filename = filename . as_posix (), colorkey = colorkey ) if image_size : width , height = image_size num_horizontal = sheet . get_rect () . width // width num_vertical = sheet . get_rect () . height // height rects = [ pygame . Rect (( width * i , height * j , width , height )) for j in range ( num_vertical ) for i in range ( num_horizontal ) ] images = [ sheet . subsurface ( rect ) for rect in rects ] images = list ( filter ( not_empty , images )) if num_images : images = images [: num_images ] else : images = [ sheet ] return images","title":"load_spritesheet()"},{"location":"reference/image/utils/#robingame.image.utils.not_empty","text":"Check if a surface has any non-zero pixels. Surface.get_bounding_rect() returns the smallest rectangle on the surface containing data. If the surface is empty, it will return Rect(0, 0, 0, 0), for which any returns False. robingame/image/utils.py 56 57 58 59 60 61 62 def not_empty ( surface : Surface ) -> bool : \"\"\" Check if a surface has any non-zero pixels. `Surface.get_bounding_rect()` returns the smallest rectangle on the surface containing data. If the surface is empty, it will return Rect(0, 0, 0, 0), for which `any` returns False. \"\"\" return any ( surface . get_bounding_rect ())","title":"not_empty()"},{"location":"reference/image/utils/#robingame.image.utils.pad_alpha","text":"Add the 4th (alpha) channel to a length 3 color tuple. By default it sets the new alpha channel to full opacity (255). Parameters: colour_tuple ( Color | tuple ) \u2013 Returns: Color \u2013 a colour robingame/image/utils.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 def pad_alpha ( colour_tuple : Color | tuple ) -> Color : \"\"\" Add the 4th (alpha) channel to a length 3 color tuple. By default it sets the new alpha channel to full opacity (255). Args: colour_tuple: Returns: a colour \"\"\" if len ( colour_tuple ) == 3 : # if no alpha channel supplied, assume it's full opacity return ( * colour_tuple , 255 ) elif len ( colour_tuple ) == 4 : return colour_tuple else : raise Exception ( \"bogus colour, man\" )","title":"pad_alpha()"},{"location":"reference/image/utils/#robingame.image.utils.recolor_image","text":"Return a recolored copy of an image. Parameters: surface ( Surface ) \u2013 input image color_mapping ( dict ) \u2013 dictionary of old colors (keys) to new colors (values). Unfortunately they have to be RGB tuples, not pygame Colors, because Color is an unhashable type... Returns: Surface \u2013 output image robingame/image/utils.py 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def recolor_image ( surface : Surface , color_mapping : dict ) -> Surface : \"\"\" Return a recolored copy of an image. Args: surface: input image color_mapping: dictionary of old colors (keys) to new colors (values). Unfortunately they have to be RGB tuples, not pygame Colors, because Color is an unhashable type... Returns: output image \"\"\" # make sure the colourmap has alpha channel on all colours color_mapping = { pad_alpha ( k ): pad_alpha ( v ) for k , v in color_mapping . items ()} width , height = surface . get_size () # surface.copy() inherits surface's colorkey; preserving transparency new_surface = surface . copy () # iterate over all the pixels in the old surface, and write a pixel to the new surface in the # corresponding position. If the colour of the present pixel has an entry in the # color_mapping dict, then write the new colour instead of the old one. for x in range ( width ): for y in range ( height ): color = surface . get_at (( x , y ))[:] new_color = color_mapping . get ( color ) if new_color : new_surface . set_at (( x , y ), pygame . Color ( * new_color )) else : new_surface . set_at (( x , y ), pygame . Color ( * color )) return new_surface","title":"recolor_image()"},{"location":"reference/image/utils/#robingame.image.utils.recolor_images","text":"Apply recolor_image to a list of images. robingame/image/utils.py 226 227 228 229 230 def recolor_images ( images : [ Surface ], colormap : dict ) -> [ Surface ]: \"\"\" Apply `recolor_image` to a list of images. \"\"\" return [ recolor_image ( image , colormap ) for image in images ]","title":"recolor_images()"},{"location":"reference/image/utils/#robingame.image.utils.scale_image","text":"Return a scaled copy of an image. Parameters: image ( Surface ) \u2013 input image scale ( float ) \u2013 factor by which to scale image Returns: Surface \u2013 output image robingame/image/utils.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def scale_image ( image : Surface , scale : float ) -> Surface : \"\"\" Return a scaled copy of an image. Args: image: input image scale: factor by which to scale image Returns: output image \"\"\" width , height = image . get_rect () . size image = pygame . transform . scale ( image , ( width * scale , height * scale )) return image","title":"scale_image()"},{"location":"reference/image/utils/#robingame.image.utils.scale_images","text":"Apply scale_image to a list of images. robingame/image/utils.py 163 164 165 166 167 def scale_images ( images : [ Surface ], scale : float ) -> [ Surface ]: \"\"\" Apply `scale_image` to a list of images. \"\"\" return [ scale_image ( image , scale ) for image in images ]","title":"scale_images()"},{"location":"reference/input/event/","text":"EventQueue Pygame's pygame.event.get() empties the queue, which makes it impossible to listen to events in more than one location. This class solves that with a sort of singleton approach. Source code in robingame/input/event.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class EventQueue : \"\"\" Pygame's pygame.event.get() empties the queue, which makes it impossible to listen to events in more than one location. This class solves that with a sort of singleton approach. \"\"\" # this is intentional. I want to store the events on the class. Only one game will be active # at once, so we'll never need more than one instance of this class. events = [] @classmethod def add ( cls , event : Union [ EventType , \"dataclass\" ]): \"\"\" Add the event to pygame's event queue, where it will stay until the .update() method is called to load it into cls.events. This prevents race conditions / order dependency where an event is added to the event queue and processed in the same tick. Args: event: object representing the event. Can be a `pygame.Event`, or a dataclass with attribute `type = pygame.event.custom_type()` \"\"\" if is_dataclass ( event ): event = PygameEvent ( event . type , ** asdict ( event )) pygame . event . post ( event ) @classmethod def update ( cls ): \"\"\" Read all the events from pygame's event queue into cls.events (also clears pygame's event queue) \"\"\" cls . events = pygame . event . get () @classmethod def filter ( cls , ** kwargs ) -> list [ EventType ]: return [ event for event in cls . events if all ( getattr ( event , attribute , None ) == value for attribute , value in kwargs . items ()) ] @classmethod def get ( cls , ** kwargs ) -> EventType | None : try : return cls . filter ( ** kwargs )[ 0 ] except IndexError : return None add ( event ) classmethod Add the event to pygame's event queue, where it will stay until the .update() method is called to load it into cls.events. This prevents race conditions / order dependency where an event is added to the event queue and processed in the same tick. Parameters: event ( Union [ EventType , dataclass ] ) \u2013 object representing the event. Can be a pygame.Event , or a dataclass with attribute type = pygame.event.custom_type() robingame/input/event.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @classmethod def add ( cls , event : Union [ EventType , \"dataclass\" ]): \"\"\" Add the event to pygame's event queue, where it will stay until the .update() method is called to load it into cls.events. This prevents race conditions / order dependency where an event is added to the event queue and processed in the same tick. Args: event: object representing the event. Can be a `pygame.Event`, or a dataclass with attribute `type = pygame.event.custom_type()` \"\"\" if is_dataclass ( event ): event = PygameEvent ( event . type , ** asdict ( event )) pygame . event . post ( event ) update () classmethod Read all the events from pygame's event queue into cls.events (also clears pygame's event queue) robingame/input/event.py 40 41 42 43 44 45 46 @classmethod def update ( cls ): \"\"\" Read all the events from pygame's event queue into cls.events (also clears pygame's event queue) \"\"\" cls . events = pygame . event . get ()","title":"EventQueue"},{"location":"reference/input/event/#eventqueue","text":"Pygame's pygame.event.get() empties the queue, which makes it impossible to listen to events in more than one location. This class solves that with a sort of singleton approach. Source code in robingame/input/event.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class EventQueue : \"\"\" Pygame's pygame.event.get() empties the queue, which makes it impossible to listen to events in more than one location. This class solves that with a sort of singleton approach. \"\"\" # this is intentional. I want to store the events on the class. Only one game will be active # at once, so we'll never need more than one instance of this class. events = [] @classmethod def add ( cls , event : Union [ EventType , \"dataclass\" ]): \"\"\" Add the event to pygame's event queue, where it will stay until the .update() method is called to load it into cls.events. This prevents race conditions / order dependency where an event is added to the event queue and processed in the same tick. Args: event: object representing the event. Can be a `pygame.Event`, or a dataclass with attribute `type = pygame.event.custom_type()` \"\"\" if is_dataclass ( event ): event = PygameEvent ( event . type , ** asdict ( event )) pygame . event . post ( event ) @classmethod def update ( cls ): \"\"\" Read all the events from pygame's event queue into cls.events (also clears pygame's event queue) \"\"\" cls . events = pygame . event . get () @classmethod def filter ( cls , ** kwargs ) -> list [ EventType ]: return [ event for event in cls . events if all ( getattr ( event , attribute , None ) == value for attribute , value in kwargs . items ()) ] @classmethod def get ( cls , ** kwargs ) -> EventType | None : try : return cls . filter ( ** kwargs )[ 0 ] except IndexError : return None","title":"EventQueue"},{"location":"reference/input/event/#robingame.input.event.EventQueue.add","text":"Add the event to pygame's event queue, where it will stay until the .update() method is called to load it into cls.events. This prevents race conditions / order dependency where an event is added to the event queue and processed in the same tick. Parameters: event ( Union [ EventType , dataclass ] ) \u2013 object representing the event. Can be a pygame.Event , or a dataclass with attribute type = pygame.event.custom_type() robingame/input/event.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @classmethod def add ( cls , event : Union [ EventType , \"dataclass\" ]): \"\"\" Add the event to pygame's event queue, where it will stay until the .update() method is called to load it into cls.events. This prevents race conditions / order dependency where an event is added to the event queue and processed in the same tick. Args: event: object representing the event. Can be a `pygame.Event`, or a dataclass with attribute `type = pygame.event.custom_type()` \"\"\" if is_dataclass ( event ): event = PygameEvent ( event . type , ** asdict ( event )) pygame . event . post ( event )","title":"add()"},{"location":"reference/input/event/#robingame.input.event.EventQueue.update","text":"Read all the events from pygame's event queue into cls.events (also clears pygame's event queue) robingame/input/event.py 40 41 42 43 44 45 46 @classmethod def update ( cls ): \"\"\" Read all the events from pygame's event queue into cls.events (also clears pygame's event queue) \"\"\" cls . events = pygame . event . get ()","title":"update()"},{"location":"reference/input/keyboard/","text":"KeyboardInputQueue Bases: InputQueue Tracks the history of the keyboard input channels. Example keyboard_handler = KeyboardInputQueue() if keyboard_handler.is_pressed(pygame.K_ESC): pygame.quit() Source code in robingame/input/keyboard.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class KeyboardInputQueue ( InputQueue ): \"\"\" Tracks the history of the keyboard input channels. Example: ``` keyboard_handler = KeyboardInputQueue() if keyboard_handler.is_pressed(pygame.K_ESC): pygame.quit() ``` \"\"\" def get_new_values ( self ) -> tuple [ int ]: scancode_wrapper = pygame . key . get_pressed () return tuple ( scancode_wrapper [ ii ] for ii in range ( len ( scancode_wrapper )))","title":"KeyboardInputQueue"},{"location":"reference/input/keyboard/#keyboardinputqueue","text":"Bases: InputQueue Tracks the history of the keyboard input channels. Example keyboard_handler = KeyboardInputQueue() if keyboard_handler.is_pressed(pygame.K_ESC): pygame.quit() Source code in robingame/input/keyboard.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class KeyboardInputQueue ( InputQueue ): \"\"\" Tracks the history of the keyboard input channels. Example: ``` keyboard_handler = KeyboardInputQueue() if keyboard_handler.is_pressed(pygame.K_ESC): pygame.quit() ``` \"\"\" def get_new_values ( self ) -> tuple [ int ]: scancode_wrapper = pygame . key . get_pressed () return tuple ( scancode_wrapper [ ii ] for ii in range ( len ( scancode_wrapper )))","title":"KeyboardInputQueue"},{"location":"reference/input/queue/","text":"InputQueue Bases: deque Provides additional functionality beyond pygame.key.get_pressed(). Contains a series of ChannelTuples which represent the state history of the input device that this queue is tracking. This input history allows us to track which keys have been pressed and released this tick. Subclasses should implement get_new_values . Source code in robingame/input/queue.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class InputQueue ( deque ): \"\"\" Provides additional functionality beyond pygame.key.get_pressed(). Contains a series of ChannelTuples which represent the state history of the input device that this queue is tracking. This input history allows us to track which keys have been pressed and released this tick. Subclasses should implement `get_new_values`. \"\"\" def __init__ ( self , queue_length = 5 ): super () . __init__ ( maxlen = queue_length ) def get_new_values ( self ) -> ChannelTuple : \"\"\" Subclasses should implement this. It should be something like pygame.key.get_pressed(). Returns: a tuple of integers representing the states of the input channels \"\"\" raise NotImplementedError def read_new_inputs ( self ): self . append ( self . get_new_values ()) def get_down ( self ) -> ChannelTuple : \"\"\" Return the keys which are currently held down. Returns: a tuple of values for each input channel. 0 = not down. Nonzero = down. \"\"\" return self [ - 1 ] if len ( self ) > 0 else Empty () def get_pressed ( self ) -> ChannelTuple : \"\"\" Return the keys that have just been pressed i.e. those that are down this tick but not the previous tick Returns: a tuple of integers for each input channel. 1 = pressed, 0 = not pressed. \"\"\" try : current = self [ - 1 ] previous = self [ - 2 ] # we HAVE to use the __getattr__ method of the ScancodeWrapper # here. Using for/in to iterate over it gives erroneous results! # That's why I'm using the index to get the values. return tuple ( int ( current [ i ] and not previous [ i ]) for ( i , c ), p in zip ( enumerate ( current ), previous ) ) except IndexError : return Empty () def get_released ( self ) -> ChannelTuple : \"\"\" Return the keys that have just been released i.e. those that are not down this tick, but were down the previous tick. Returns: a tuple of integers for each input channel. 1 = released, 0 = not released. \"\"\" try : current = self [ - 1 ] previous = self [ - 2 ] return tuple ( int ( previous [ i ] and not current [ i ]) for ( i , c ), p in zip ( enumerate ( current ), previous ) ) except IndexError : return Empty () def is_pressed ( self , key ) -> int : \"\"\" Check if a key has been pressed this tick Returns: 1 if pressed; 0 otherwise \"\"\" keys = self . get_pressed () return keys [ key ] def is_down ( self , key ) -> int : \"\"\" Check if a key is currently held down Returns: 1 if down; 0 otherwise \"\"\" keys = self . get_down () return keys [ key ] def is_released ( self , key ) -> int : \"\"\" Check if a key has been released this tick Returns: 1 if released; 0 otherwise \"\"\" keys = self . get_released () return keys [ key ] def buffered_inputs ( self , key : int , buffer_length : int ) -> tuple [ int , int ]: \"\"\" Count the rising and falling edges. Can be used to detect past inputs. Args: key: identifier of the input channel buffer_length: how many past iterations to consider Returns: number of times the input channel has been pressed and released over the `buffer_length` \"\"\" buffer = list ( self )[ - buffer_length :] values = [ layer [ key ] for layer in buffer ] return count_edges ( values ) def buffered_presses ( self , key , buffer_length ): rising , falling = self . buffered_inputs ( key , buffer_length ) return rising def buffered_releases ( self , key , buffer_length ): rising , falling = self . buffered_inputs ( key , buffer_length ) return falling buffered_inputs ( key , buffer_length ) Count the rising and falling edges. Can be used to detect past inputs. Parameters: key ( int ) \u2013 identifier of the input channel buffer_length ( int ) \u2013 how many past iterations to consider Returns: tuple [ int , int ] \u2013 number of times the input channel has been pressed and released over the buffer_length robingame/input/queue.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def buffered_inputs ( self , key : int , buffer_length : int ) -> tuple [ int , int ]: \"\"\" Count the rising and falling edges. Can be used to detect past inputs. Args: key: identifier of the input channel buffer_length: how many past iterations to consider Returns: number of times the input channel has been pressed and released over the `buffer_length` \"\"\" buffer = list ( self )[ - buffer_length :] values = [ layer [ key ] for layer in buffer ] return count_edges ( values ) get_down () Return the keys which are currently held down. Returns: ChannelTuple \u2013 a tuple of values for each input channel. 0 = not down. Nonzero = down. robingame/input/queue.py 51 52 53 54 55 56 57 58 def get_down ( self ) -> ChannelTuple : \"\"\" Return the keys which are currently held down. Returns: a tuple of values for each input channel. 0 = not down. Nonzero = down. \"\"\" return self [ - 1 ] if len ( self ) > 0 else Empty () get_new_values () Subclasses should implement this. It should be something like pygame.key.get_pressed(). Returns: ChannelTuple \u2013 a tuple of integers representing the states of the input channels robingame/input/queue.py 38 39 40 41 42 43 44 45 46 def get_new_values ( self ) -> ChannelTuple : \"\"\" Subclasses should implement this. It should be something like pygame.key.get_pressed(). Returns: a tuple of integers representing the states of the input channels \"\"\" raise NotImplementedError get_pressed () Return the keys that have just been pressed i.e. those that are down this tick but not the previous tick Returns: ChannelTuple \u2013 a tuple of integers for each input channel. 1 = pressed, 0 = not pressed. robingame/input/queue.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def get_pressed ( self ) -> ChannelTuple : \"\"\" Return the keys that have just been pressed i.e. those that are down this tick but not the previous tick Returns: a tuple of integers for each input channel. 1 = pressed, 0 = not pressed. \"\"\" try : current = self [ - 1 ] previous = self [ - 2 ] # we HAVE to use the __getattr__ method of the ScancodeWrapper # here. Using for/in to iterate over it gives erroneous results! # That's why I'm using the index to get the values. return tuple ( int ( current [ i ] and not previous [ i ]) for ( i , c ), p in zip ( enumerate ( current ), previous ) ) except IndexError : return Empty () get_released () Return the keys that have just been released i.e. those that are not down this tick, but were down the previous tick. Returns: ChannelTuple \u2013 a tuple of integers for each input channel. 1 = released, 0 = not released. robingame/input/queue.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_released ( self ) -> ChannelTuple : \"\"\" Return the keys that have just been released i.e. those that are not down this tick, but were down the previous tick. Returns: a tuple of integers for each input channel. 1 = released, 0 = not released. \"\"\" try : current = self [ - 1 ] previous = self [ - 2 ] return tuple ( int ( previous [ i ] and not current [ i ]) for ( i , c ), p in zip ( enumerate ( current ), previous ) ) except IndexError : return Empty () is_down ( key ) Check if a key is currently held down Returns: int \u2013 1 if down; 0 otherwise robingame/input/queue.py 109 110 111 112 113 114 115 116 117 def is_down ( self , key ) -> int : \"\"\" Check if a key is currently held down Returns: 1 if down; 0 otherwise \"\"\" keys = self . get_down () return keys [ key ] is_pressed ( key ) Check if a key has been pressed this tick Returns: int \u2013 1 if pressed; 0 otherwise robingame/input/queue.py 99 100 101 102 103 104 105 106 107 def is_pressed ( self , key ) -> int : \"\"\" Check if a key has been pressed this tick Returns: 1 if pressed; 0 otherwise \"\"\" keys = self . get_pressed () return keys [ key ] is_released ( key ) Check if a key has been released this tick Returns: int \u2013 1 if released; 0 otherwise robingame/input/queue.py 119 120 121 122 123 124 125 126 127 def is_released ( self , key ) -> int : \"\"\" Check if a key has been released this tick Returns: 1 if released; 0 otherwise \"\"\" keys = self . get_released () return keys [ key ]","title":"InputQueue"},{"location":"reference/input/queue/#inputqueue","text":"Bases: deque Provides additional functionality beyond pygame.key.get_pressed(). Contains a series of ChannelTuples which represent the state history of the input device that this queue is tracking. This input history allows us to track which keys have been pressed and released this tick. Subclasses should implement get_new_values . Source code in robingame/input/queue.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class InputQueue ( deque ): \"\"\" Provides additional functionality beyond pygame.key.get_pressed(). Contains a series of ChannelTuples which represent the state history of the input device that this queue is tracking. This input history allows us to track which keys have been pressed and released this tick. Subclasses should implement `get_new_values`. \"\"\" def __init__ ( self , queue_length = 5 ): super () . __init__ ( maxlen = queue_length ) def get_new_values ( self ) -> ChannelTuple : \"\"\" Subclasses should implement this. It should be something like pygame.key.get_pressed(). Returns: a tuple of integers representing the states of the input channels \"\"\" raise NotImplementedError def read_new_inputs ( self ): self . append ( self . get_new_values ()) def get_down ( self ) -> ChannelTuple : \"\"\" Return the keys which are currently held down. Returns: a tuple of values for each input channel. 0 = not down. Nonzero = down. \"\"\" return self [ - 1 ] if len ( self ) > 0 else Empty () def get_pressed ( self ) -> ChannelTuple : \"\"\" Return the keys that have just been pressed i.e. those that are down this tick but not the previous tick Returns: a tuple of integers for each input channel. 1 = pressed, 0 = not pressed. \"\"\" try : current = self [ - 1 ] previous = self [ - 2 ] # we HAVE to use the __getattr__ method of the ScancodeWrapper # here. Using for/in to iterate over it gives erroneous results! # That's why I'm using the index to get the values. return tuple ( int ( current [ i ] and not previous [ i ]) for ( i , c ), p in zip ( enumerate ( current ), previous ) ) except IndexError : return Empty () def get_released ( self ) -> ChannelTuple : \"\"\" Return the keys that have just been released i.e. those that are not down this tick, but were down the previous tick. Returns: a tuple of integers for each input channel. 1 = released, 0 = not released. \"\"\" try : current = self [ - 1 ] previous = self [ - 2 ] return tuple ( int ( previous [ i ] and not current [ i ]) for ( i , c ), p in zip ( enumerate ( current ), previous ) ) except IndexError : return Empty () def is_pressed ( self , key ) -> int : \"\"\" Check if a key has been pressed this tick Returns: 1 if pressed; 0 otherwise \"\"\" keys = self . get_pressed () return keys [ key ] def is_down ( self , key ) -> int : \"\"\" Check if a key is currently held down Returns: 1 if down; 0 otherwise \"\"\" keys = self . get_down () return keys [ key ] def is_released ( self , key ) -> int : \"\"\" Check if a key has been released this tick Returns: 1 if released; 0 otherwise \"\"\" keys = self . get_released () return keys [ key ] def buffered_inputs ( self , key : int , buffer_length : int ) -> tuple [ int , int ]: \"\"\" Count the rising and falling edges. Can be used to detect past inputs. Args: key: identifier of the input channel buffer_length: how many past iterations to consider Returns: number of times the input channel has been pressed and released over the `buffer_length` \"\"\" buffer = list ( self )[ - buffer_length :] values = [ layer [ key ] for layer in buffer ] return count_edges ( values ) def buffered_presses ( self , key , buffer_length ): rising , falling = self . buffered_inputs ( key , buffer_length ) return rising def buffered_releases ( self , key , buffer_length ): rising , falling = self . buffered_inputs ( key , buffer_length ) return falling","title":"InputQueue"},{"location":"reference/input/queue/#robingame.input.queue.InputQueue.buffered_inputs","text":"Count the rising and falling edges. Can be used to detect past inputs. Parameters: key ( int ) \u2013 identifier of the input channel buffer_length ( int ) \u2013 how many past iterations to consider Returns: tuple [ int , int ] \u2013 number of times the input channel has been pressed and released over the buffer_length robingame/input/queue.py 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def buffered_inputs ( self , key : int , buffer_length : int ) -> tuple [ int , int ]: \"\"\" Count the rising and falling edges. Can be used to detect past inputs. Args: key: identifier of the input channel buffer_length: how many past iterations to consider Returns: number of times the input channel has been pressed and released over the `buffer_length` \"\"\" buffer = list ( self )[ - buffer_length :] values = [ layer [ key ] for layer in buffer ] return count_edges ( values )","title":"buffered_inputs()"},{"location":"reference/input/queue/#robingame.input.queue.InputQueue.get_down","text":"Return the keys which are currently held down. Returns: ChannelTuple \u2013 a tuple of values for each input channel. 0 = not down. Nonzero = down. robingame/input/queue.py 51 52 53 54 55 56 57 58 def get_down ( self ) -> ChannelTuple : \"\"\" Return the keys which are currently held down. Returns: a tuple of values for each input channel. 0 = not down. Nonzero = down. \"\"\" return self [ - 1 ] if len ( self ) > 0 else Empty ()","title":"get_down()"},{"location":"reference/input/queue/#robingame.input.queue.InputQueue.get_new_values","text":"Subclasses should implement this. It should be something like pygame.key.get_pressed(). Returns: ChannelTuple \u2013 a tuple of integers representing the states of the input channels robingame/input/queue.py 38 39 40 41 42 43 44 45 46 def get_new_values ( self ) -> ChannelTuple : \"\"\" Subclasses should implement this. It should be something like pygame.key.get_pressed(). Returns: a tuple of integers representing the states of the input channels \"\"\" raise NotImplementedError","title":"get_new_values()"},{"location":"reference/input/queue/#robingame.input.queue.InputQueue.get_pressed","text":"Return the keys that have just been pressed i.e. those that are down this tick but not the previous tick Returns: ChannelTuple \u2013 a tuple of integers for each input channel. 1 = pressed, 0 = not pressed. robingame/input/queue.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 def get_pressed ( self ) -> ChannelTuple : \"\"\" Return the keys that have just been pressed i.e. those that are down this tick but not the previous tick Returns: a tuple of integers for each input channel. 1 = pressed, 0 = not pressed. \"\"\" try : current = self [ - 1 ] previous = self [ - 2 ] # we HAVE to use the __getattr__ method of the ScancodeWrapper # here. Using for/in to iterate over it gives erroneous results! # That's why I'm using the index to get the values. return tuple ( int ( current [ i ] and not previous [ i ]) for ( i , c ), p in zip ( enumerate ( current ), previous ) ) except IndexError : return Empty ()","title":"get_pressed()"},{"location":"reference/input/queue/#robingame.input.queue.InputQueue.get_released","text":"Return the keys that have just been released i.e. those that are not down this tick, but were down the previous tick. Returns: ChannelTuple \u2013 a tuple of integers for each input channel. 1 = released, 0 = not released. robingame/input/queue.py 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def get_released ( self ) -> ChannelTuple : \"\"\" Return the keys that have just been released i.e. those that are not down this tick, but were down the previous tick. Returns: a tuple of integers for each input channel. 1 = released, 0 = not released. \"\"\" try : current = self [ - 1 ] previous = self [ - 2 ] return tuple ( int ( previous [ i ] and not current [ i ]) for ( i , c ), p in zip ( enumerate ( current ), previous ) ) except IndexError : return Empty ()","title":"get_released()"},{"location":"reference/input/queue/#robingame.input.queue.InputQueue.is_down","text":"Check if a key is currently held down Returns: int \u2013 1 if down; 0 otherwise robingame/input/queue.py 109 110 111 112 113 114 115 116 117 def is_down ( self , key ) -> int : \"\"\" Check if a key is currently held down Returns: 1 if down; 0 otherwise \"\"\" keys = self . get_down () return keys [ key ]","title":"is_down()"},{"location":"reference/input/queue/#robingame.input.queue.InputQueue.is_pressed","text":"Check if a key has been pressed this tick Returns: int \u2013 1 if pressed; 0 otherwise robingame/input/queue.py 99 100 101 102 103 104 105 106 107 def is_pressed ( self , key ) -> int : \"\"\" Check if a key has been pressed this tick Returns: 1 if pressed; 0 otherwise \"\"\" keys = self . get_pressed () return keys [ key ]","title":"is_pressed()"},{"location":"reference/input/queue/#robingame.input.queue.InputQueue.is_released","text":"Check if a key has been released this tick Returns: int \u2013 1 if released; 0 otherwise robingame/input/queue.py 119 120 121 122 123 124 125 126 127 def is_released ( self , key ) -> int : \"\"\" Check if a key has been released this tick Returns: 1 if released; 0 otherwise \"\"\" keys = self . get_released () return keys [ key ]","title":"is_released()"},{"location":"reference/objects/entity/","text":"Entity Bases: pygame . sprite . Sprite Finite State Machine: self.state is executed every tick self.tick is incremented every time the main game loop executes when self.state changes, self.tick is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: Entities can be added to Groups to create a hierarchical structure The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity Source code in robingame/objects/entity.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Entity ( pygame . sprite . Sprite ): \"\"\" Finite State Machine: - `self.state` is executed every tick - `self.tick` is incremented every time the main game loop executes - when `self.state` changes, `self.tick` is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: - `Entities` can be added to `Groups` to create a hierarchical structure - The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: ``` Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity ``` \"\"\" _state : Callable = lambda * args , ** kwargs : None # default state: do nothing child_groups : list [ Group ] # groups of child Entities belonging to this entity tick : int = 0 # number of game loop iterations elapsed in the current state def __init__ ( self , groups : Iterable [ Group ] = ()): super () . __init__ ( * groups ) self . child_groups = [] def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill () @property def state ( self ): \"\"\"Execute the current state function.\"\"\" return self . _state @state . setter def state ( self , new_state ): \"\"\" Reset self.tick when state changes so we know how long we've been in the current state. \"\"\" self . _state = new_state self . tick = 0 def __repr__ ( self ): # The `_Sprite__g` is necessary because of name mangling in subclasses I think return f \"< { self . __class__ . __name__ } Entity(in { len ( self . _Sprite__g ) } groups)>\" state property writable Execute the current state function. draw ( surface , debug = False ) Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Parameters: surface ( Surface ) \u2013 the surface (usually the screen) on which to draw self debug ( bool ) \u2013 if True, draw extra stuff for debugging robingame/objects/entity.py 65 66 67 68 69 70 71 72 73 74 75 76 def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) kill () Removes self from all groups. robingame/objects/entity.py 78 79 80 81 82 def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill () update () Execute self.state . Call .update() on all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment self.tick to keep track of how long we've been in the current state. robingame/objects/entity.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state","title":"Entity"},{"location":"reference/objects/entity/#entity","text":"Bases: pygame . sprite . Sprite Finite State Machine: self.state is executed every tick self.tick is incremented every time the main game loop executes when self.state changes, self.tick is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: Entities can be added to Groups to create a hierarchical structure The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity Source code in robingame/objects/entity.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Entity ( pygame . sprite . Sprite ): \"\"\" Finite State Machine: - `self.state` is executed every tick - `self.tick` is incremented every time the main game loop executes - when `self.state` changes, `self.tick` is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: - `Entities` can be added to `Groups` to create a hierarchical structure - The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: ``` Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity ``` \"\"\" _state : Callable = lambda * args , ** kwargs : None # default state: do nothing child_groups : list [ Group ] # groups of child Entities belonging to this entity tick : int = 0 # number of game loop iterations elapsed in the current state def __init__ ( self , groups : Iterable [ Group ] = ()): super () . __init__ ( * groups ) self . child_groups = [] def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill () @property def state ( self ): \"\"\"Execute the current state function.\"\"\" return self . _state @state . setter def state ( self , new_state ): \"\"\" Reset self.tick when state changes so we know how long we've been in the current state. \"\"\" self . _state = new_state self . tick = 0 def __repr__ ( self ): # The `_Sprite__g` is necessary because of name mangling in subclasses I think return f \"< { self . __class__ . __name__ } Entity(in { len ( self . _Sprite__g ) } groups)>\"","title":"Entity"},{"location":"reference/objects/entity/#robingame.objects.entity.Entity.state","text":"Execute the current state function.","title":"state"},{"location":"reference/objects/entity/#robingame.objects.entity.Entity.draw","text":"Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Parameters: surface ( Surface ) \u2013 the surface (usually the screen) on which to draw self debug ( bool ) \u2013 if True, draw extra stuff for debugging robingame/objects/entity.py 65 66 67 68 69 70 71 72 73 74 75 76 def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug )","title":"draw()"},{"location":"reference/objects/entity/#robingame.objects.entity.Entity.kill","text":"Removes self from all groups. robingame/objects/entity.py 78 79 80 81 82 def kill ( self ): \"\"\"Removes self from all groups.\"\"\" for group in self . child_groups : group . kill () super () . kill ()","title":"kill()"},{"location":"reference/objects/entity/#robingame.objects.entity.Entity.update","text":"Execute self.state . Call .update() on all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment self.tick to keep track of how long we've been in the current state. robingame/objects/entity.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def update ( self ): \"\"\" Execute `self.state`. Call `.update()` on all child groups. This allows the entire tree of objects to update by only calling the `.update()` method of the root object. Subclasses can override this method to provide subclass-specific behaviour. However, it's generally a better idea to write state functions and allow the Entity's Finite State Machine mechanism to execute them. Increment `self.tick` to keep track of how long we've been in the current state. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state","title":"update()"},{"location":"reference/objects/game/","text":"Game Example usage: # your_game.py from levels import Level1 # Level1 is an entity class MyGame(Game): def __init__(self): super().__init__() self.children = Group() self.child_groups = [self.children] self.children.add(Level1(...)) if __name__ == \"__main__\": MyGame().main() Bases: Entity Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: initialising the display setting up and running the main game loop. doing clock.tick() every iteration and enforcing the framerate filling the screen with self.screen_color every iteration updating the EventQueue with new events maintaining the FPS tracker (and drawing it in debug mode) Source code in robingame/objects/game.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Game ( Entity ): \"\"\" Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: - initialising the display - setting up and running the main game loop. - doing `clock.tick()` every iteration and enforcing the framerate - filling the screen with `self.screen_color` every iteration - updating the EventQueue with new events - maintaining the FPS tracker (and drawing it in debug mode) \"\"\" fps : int = 60 window_width : int = 500 window_height : int = 500 window_caption : str = \"Game\" screen_color = Color ( \"black\" ) debug : bool = False # draw / print debug info? running : bool # is the main game loop running def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock () def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit () def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass def _update ( self ): \"\"\" 1. read inputs 2. update \"\"\" self . read_inputs () if self . debug : self . print_debug_info () self . update () self . fps_tracker . update () if self . fps : self . clock . tick ( self . fps ) def _draw ( self , surface : Surface , debug : bool = False ): surface . fill ( self . screen_color ) # clear the screen self . draw ( surface , debug ) self . fps_tracker . draw ( surface , debug ) pygame . display . update () # print to screen __init__ () Handles a lot of the boilerplate pygame setup. Creates the display ( self.window ). robingame/objects/game.py 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock () main () Contains the main game loop. Calls self._update() and self._draw() on every iteration of the game loop. robingame/objects/game.py 46 47 48 49 50 51 52 53 54 55 56 def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit () print_debug_info () Override this if you want to print any debug info. robingame/objects/game.py 76 77 78 79 80 def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass read_inputs () Called by self._update() , before super().update() updates the children. Any code that polls external joysticks/controllers should go here. robingame/objects/game.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug","title":"Game"},{"location":"reference/objects/game/#game","text":"Example usage: # your_game.py from levels import Level1 # Level1 is an entity class MyGame(Game): def __init__(self): super().__init__() self.children = Group() self.child_groups = [self.children] self.children.add(Level1(...)) if __name__ == \"__main__\": MyGame().main() Bases: Entity Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: initialising the display setting up and running the main game loop. doing clock.tick() every iteration and enforcing the framerate filling the screen with self.screen_color every iteration updating the EventQueue with new events maintaining the FPS tracker (and drawing it in debug mode) Source code in robingame/objects/game.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 class Game ( Entity ): \"\"\" Special case of Entity; it is at the very top of the object tree. Handles much of the pygame boilerplate setup, including: - initialising the display - setting up and running the main game loop. - doing `clock.tick()` every iteration and enforcing the framerate - filling the screen with `self.screen_color` every iteration - updating the EventQueue with new events - maintaining the FPS tracker (and drawing it in debug mode) \"\"\" fps : int = 60 window_width : int = 500 window_height : int = 500 window_caption : str = \"Game\" screen_color = Color ( \"black\" ) debug : bool = False # draw / print debug info? running : bool # is the main game loop running def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock () def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit () def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass def _update ( self ): \"\"\" 1. read inputs 2. update \"\"\" self . read_inputs () if self . debug : self . print_debug_info () self . update () self . fps_tracker . update () if self . fps : self . clock . tick ( self . fps ) def _draw ( self , surface : Surface , debug : bool = False ): surface . fill ( self . screen_color ) # clear the screen self . draw ( surface , debug ) self . fps_tracker . draw ( surface , debug ) pygame . display . update () # print to screen","title":"Game"},{"location":"reference/objects/game/#robingame.objects.game.Game.__init__","text":"Handles a lot of the boilerplate pygame setup. Creates the display ( self.window ). robingame/objects/game.py 34 35 36 37 38 39 40 41 42 43 44 def __init__ ( self ): \"\"\" Handles a lot of the boilerplate pygame setup. Creates the display (`self.window`). \"\"\" super () . __init__ () pygame . init () self . fps_tracker = FpsTracker () self . window = pygame . display . set_mode (( self . window_width , self . window_height )) pygame . display . set_caption ( self . window_caption ) self . clock = pygame . time . Clock ()","title":"__init__()"},{"location":"reference/objects/game/#robingame.objects.game.Game.main","text":"Contains the main game loop. Calls self._update() and self._draw() on every iteration of the game loop. robingame/objects/game.py 46 47 48 49 50 51 52 53 54 55 56 def main ( self ): \"\"\" Contains the main game loop. Calls `self._update()` and `self._draw()` on every iteration of the game loop. \"\"\" self . running = True while self . running : self . _update () self . _draw ( self . window , debug = self . debug ) pygame . quit () sys . exit ()","title":"main()"},{"location":"reference/objects/game/#robingame.objects.game.Game.print_debug_info","text":"Override this if you want to print any debug info. robingame/objects/game.py 76 77 78 79 80 def print_debug_info ( self ): \"\"\" Override this if you want to print any debug info. \"\"\" pass","title":"print_debug_info()"},{"location":"reference/objects/game/#robingame.objects.game.Game.read_inputs","text":"Called by self._update() , before super().update() updates the children. Any code that polls external joysticks/controllers should go here. robingame/objects/game.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def read_inputs ( self ): \"\"\" Called by `self._update()`, before `super().update()` updates the children. Any code that polls external joysticks/controllers should go here. \"\"\" # I've put this in a separate method because I don't like the idea of putting the inputs # in the same list as other child groups. The order might get ruined, or a subclass might # overwrite the list. It's crucial that the inputs are read before updating. EventQueue . update () for event in EventQueue . events : if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN and event . key == pygame . K_F1 : self . debug = not self . debug","title":"read_inputs()"},{"location":"reference/objects/group/","text":"Group Bases: pygame . sprite . Group Container for multiple Entities. Source code in robingame/objects/group.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Group ( pygame . sprite . Group ): \"\"\"Container for multiple Entities.\"\"\" def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities ) def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args ) def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = [] def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill () add ( * entities ) Does the same thing as pygame's Group.add() . Only overriding this because pygame's typing was making the linter complain. robingame/objects/group.py 11 12 13 14 15 16 def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities ) draw ( surface , debug = False ) Call .draw(surface, debug) on all member Entities. This is different from pygame's Group.draw() in that it calls the Entity.draw() method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's .image onto the surface. robingame/objects/group.py 24 25 26 27 28 29 30 31 32 33 34 35 def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = [] kill () Call .kill() on all the entities in this group. This is different from Group.empty() . robingame/objects/group.py 37 38 39 40 41 42 43 def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill () update ( * args ) Call .update() on all member Entities. robingame/objects/group.py 18 19 20 21 22 def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args )","title":"Group"},{"location":"reference/objects/group/#group","text":"Bases: pygame . sprite . Group Container for multiple Entities. Source code in robingame/objects/group.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Group ( pygame . sprite . Group ): \"\"\"Container for multiple Entities.\"\"\" def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities ) def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args ) def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = [] def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill ()","title":"Group"},{"location":"reference/objects/group/#robingame.objects.group.Group.add","text":"Does the same thing as pygame's Group.add() . Only overriding this because pygame's typing was making the linter complain. robingame/objects/group.py 11 12 13 14 15 16 def add ( self , * entities : \"Entity\" ) -> None : \"\"\" Does the same thing as pygame's `Group.add()`. Only overriding this because pygame's typing was making the linter complain. \"\"\" super () . add ( * entities )","title":"add()"},{"location":"reference/objects/group/#robingame.objects.group.Group.draw","text":"Call .draw(surface, debug) on all member Entities. This is different from pygame's Group.draw() in that it calls the Entity.draw() method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's .image onto the surface. robingame/objects/group.py 24 25 26 27 28 29 30 31 32 33 34 35 def draw ( self , surface : pygame . Surface , debug : bool = False ): \"\"\" Call `.draw(surface, debug)` on all member Entities. This is different from pygame's `Group.draw()` in that it calls the `Entity.draw()` method (thus allowing the Entity to decide how to draw itself) instead of just blitting the Entity's `.image` onto the surface. \"\"\" entities = self . sprites () for entity in entities : entity . draw ( surface , debug ) self . lostsprites = []","title":"draw()"},{"location":"reference/objects/group/#robingame.objects.group.Group.kill","text":"Call .kill() on all the entities in this group. This is different from Group.empty() . robingame/objects/group.py 37 38 39 40 41 42 43 def kill ( self ): \"\"\" Call `.kill()` on all the entities in this group. This is different from `Group.empty()`. \"\"\" for entity in self : entity . kill ()","title":"kill()"},{"location":"reference/objects/group/#robingame.objects.group.Group.update","text":"Call .update() on all member Entities. robingame/objects/group.py 18 19 20 21 22 def update ( self , * args ): \"\"\" Call `.update()` on all member Entities. \"\"\" super () . update ( * args )","title":"update()"},{"location":"reference/text/font/","text":"Font Handles loading custom fonts from a spritesheet, and rendering text onto a surface. Source code in robingame/text/font.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 class Font : \"\"\" Handles loading custom fonts from a spritesheet, and rendering text onto a surface. \"\"\" letters : dict [ str : Surface ] image_size : tuple [ int , int ] xpad : int ypad : int def __init__ ( self , filename : str | Path , image_size : tuple [ int , int ], letters : str , xpad : int = 0 , ypad : int = 0 , trim : bool = False , space_width : int = None , ** kwargs : dict , ): \"\"\" Loads the font from a spritesheet of letters using `load_spritesheet`. Args: filename: path to the spritesheet of letters image_size: the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters: describes the order in which the characters appear in the spritesheet xpad: extra x space between characters (in pixels). Can be negative ypad: extra y space between characters (in pixels). Can be negative trim: if `True`, trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If `False`, leave the characters equal width (results in a monospaced font) space_width: desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs: any extra kwargs will be passed on to `load_spritesheet` Example: ``` test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) ``` \"\"\" self . image_size = width , height = image_size self . xpad = xpad self . ypad = ypad self . letters = dict () self . letters [ \" \" ] = empty_image (( space_width or width , height )) self . not_found = Surface ( image_size ) self . not_found . fill ( Color ( \"red\" )) images = load_spritesheet ( filename , image_size = image_size , ** kwargs ) if trim : images = self . _trim_images ( images ) self . letters . update ({ letter : image for letter , image in zip ( letters , images )}) def render ( self , surf : Surface , text : str , x : int = 0 , y : int = 0 , scale : int = 1 , wrap : int = 0 , align : int = None , ) -> int : \"\"\" Render text onto a surface. Args: surf: surface on which to render the text text: the string of characters to render in this font x: x-position on the surface y: y-position on the surface scale: factor by which to scale the text (1 = no scaling) wrap: x width at which to wrap text align: -1=left, 0=center, 1=right Example: ``` test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) ``` \"\"\" _ , ysize = self . image_size cursor = x for line in text . splitlines (): wrapped_lines = self . _wrap_words ( line , wrap , x , scale ) if wrap else [ line ] for line in wrapped_lines : cursor = self . _align_cursor ( line , x , align , scale , wrap ) for letter in line : image = self . get ( letter ) image = scale_image ( image , scale ) surf . blit ( image , ( cursor , y )) w = image . get_width () cursor += w + self . xpad * scale y += ( ysize + self . ypad ) * scale return cursor def get ( self , letter : str ) -> Surface : \"\"\" Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Args: letter: \"\"\" try : return self . letters [ letter ] except KeyError : return self . not_found def _align_cursor ( self , line : str , x : int , align : int , scale : int , wrap : int ) -> int : \"\"\" Used for left/right/centered text alignmnent \"\"\" match align : case - 1 | None : cursor = x case 0 : if not wrap : raise TextError ( \"Can't center text without specifying a wrap width.\" ) line_width = self . _printed_width ( line , scale ) slack = wrap - line_width cursor = x + slack // 2 case 1 : line_width = self . _printed_width ( line , scale ) cursor = x + wrap - line_width case _ : raise TextError ( f \"Bad alignment value: { align } \" ) return cursor def _wrap_words ( self , text : str , wrap : int , x : int = 0 , scale : int = 1 ) -> list [ str ]: \"\"\" Break one long line into multiple lines based on the wrap width. \"\"\" lines = [] line = \"\" for word in text . split ( \" \" ): new_line = f \" { line } { word } \" if line else word if self . _printed_width ( new_line , scale ) <= wrap : line = new_line else : lines . append ( line ) line = word lines . append ( line ) # last line return lines def _printed_width ( self , text : str , scale : int ) -> int : \"\"\" Calculate how wide a string of text will be when rendered. \"\"\" return sum (( self . get ( letter ) . get_width () + self . xpad ) * scale for letter in text ) def _trim_images ( self , images : list [ Surface ]) -> list [ Surface ]: \"\"\" Make a monospaced font non-monospaced \"\"\" trimmed = [] for image in images : x , _ , w , _ = image . get_bounding_rect () # trim x to bounding rect _ , y , _ , h = image . get_rect () # maintain original y position of character new = image . subsurface (( x , y , w , h )) trimmed . append ( new ) return trimmed __init__ ( filename , image_size , letters , xpad = 0 , ypad = 0 , trim = False , space_width = None , ** kwargs ) Loads the font from a spritesheet of letters using load_spritesheet . Parameters: filename ( str | Path ) \u2013 path to the spritesheet of letters image_size ( tuple [ int , int ] ) \u2013 the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters ( str ) \u2013 describes the order in which the characters appear in the spritesheet xpad ( int ) \u2013 extra x space between characters (in pixels). Can be negative ypad ( int ) \u2013 extra y space between characters (in pixels). Can be negative trim ( bool ) \u2013 if True , trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If False , leave the characters equal width (results in a monospaced font) space_width ( int ) \u2013 desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs ( dict ) \u2013 any extra kwargs will be passed on to load_spritesheet Example test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) robingame/text/font.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , filename : str | Path , image_size : tuple [ int , int ], letters : str , xpad : int = 0 , ypad : int = 0 , trim : bool = False , space_width : int = None , ** kwargs : dict , ): \"\"\" Loads the font from a spritesheet of letters using `load_spritesheet`. Args: filename: path to the spritesheet of letters image_size: the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters: describes the order in which the characters appear in the spritesheet xpad: extra x space between characters (in pixels). Can be negative ypad: extra y space between characters (in pixels). Can be negative trim: if `True`, trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If `False`, leave the characters equal width (results in a monospaced font) space_width: desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs: any extra kwargs will be passed on to `load_spritesheet` Example: ``` test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) ``` \"\"\" self . image_size = width , height = image_size self . xpad = xpad self . ypad = ypad self . letters = dict () self . letters [ \" \" ] = empty_image (( space_width or width , height )) self . not_found = Surface ( image_size ) self . not_found . fill ( Color ( \"red\" )) images = load_spritesheet ( filename , image_size = image_size , ** kwargs ) if trim : images = self . _trim_images ( images ) self . letters . update ({ letter : image for letter , image in zip ( letters , images )}) get ( letter ) Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Parameters: letter ( str ) \u2013 robingame/text/font.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def get ( self , letter : str ) -> Surface : \"\"\" Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Args: letter: \"\"\" try : return self . letters [ letter ] except KeyError : return self . not_found render ( surf , text , x = 0 , y = 0 , scale = 1 , wrap = 0 , align = None ) Render text onto a surface. Parameters: surf ( Surface ) \u2013 surface on which to render the text text ( str ) \u2013 the string of characters to render in this font x ( int ) \u2013 x-position on the surface y ( int ) \u2013 y-position on the surface scale ( int ) \u2013 factor by which to scale the text (1 = no scaling) wrap ( int ) \u2013 x width at which to wrap text align ( int ) \u2013 -1=left, 0=center, 1=right Example test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) robingame/text/font.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def render ( self , surf : Surface , text : str , x : int = 0 , y : int = 0 , scale : int = 1 , wrap : int = 0 , align : int = None , ) -> int : \"\"\" Render text onto a surface. Args: surf: surface on which to render the text text: the string of characters to render in this font x: x-position on the surface y: y-position on the surface scale: factor by which to scale the text (1 = no scaling) wrap: x width at which to wrap text align: -1=left, 0=center, 1=right Example: ``` test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) ``` \"\"\" _ , ysize = self . image_size cursor = x for line in text . splitlines (): wrapped_lines = self . _wrap_words ( line , wrap , x , scale ) if wrap else [ line ] for line in wrapped_lines : cursor = self . _align_cursor ( line , x , align , scale , wrap ) for letter in line : image = self . get ( letter ) image = scale_image ( image , scale ) surf . blit ( image , ( cursor , y )) w = image . get_width () cursor += w + self . xpad * scale y += ( ysize + self . ypad ) * scale return cursor","title":"Font"},{"location":"reference/text/font/#font","text":"Handles loading custom fonts from a spritesheet, and rendering text onto a surface. Source code in robingame/text/font.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 class Font : \"\"\" Handles loading custom fonts from a spritesheet, and rendering text onto a surface. \"\"\" letters : dict [ str : Surface ] image_size : tuple [ int , int ] xpad : int ypad : int def __init__ ( self , filename : str | Path , image_size : tuple [ int , int ], letters : str , xpad : int = 0 , ypad : int = 0 , trim : bool = False , space_width : int = None , ** kwargs : dict , ): \"\"\" Loads the font from a spritesheet of letters using `load_spritesheet`. Args: filename: path to the spritesheet of letters image_size: the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters: describes the order in which the characters appear in the spritesheet xpad: extra x space between characters (in pixels). Can be negative ypad: extra y space between characters (in pixels). Can be negative trim: if `True`, trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If `False`, leave the characters equal width (results in a monospaced font) space_width: desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs: any extra kwargs will be passed on to `load_spritesheet` Example: ``` test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) ``` \"\"\" self . image_size = width , height = image_size self . xpad = xpad self . ypad = ypad self . letters = dict () self . letters [ \" \" ] = empty_image (( space_width or width , height )) self . not_found = Surface ( image_size ) self . not_found . fill ( Color ( \"red\" )) images = load_spritesheet ( filename , image_size = image_size , ** kwargs ) if trim : images = self . _trim_images ( images ) self . letters . update ({ letter : image for letter , image in zip ( letters , images )}) def render ( self , surf : Surface , text : str , x : int = 0 , y : int = 0 , scale : int = 1 , wrap : int = 0 , align : int = None , ) -> int : \"\"\" Render text onto a surface. Args: surf: surface on which to render the text text: the string of characters to render in this font x: x-position on the surface y: y-position on the surface scale: factor by which to scale the text (1 = no scaling) wrap: x width at which to wrap text align: -1=left, 0=center, 1=right Example: ``` test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) ``` \"\"\" _ , ysize = self . image_size cursor = x for line in text . splitlines (): wrapped_lines = self . _wrap_words ( line , wrap , x , scale ) if wrap else [ line ] for line in wrapped_lines : cursor = self . _align_cursor ( line , x , align , scale , wrap ) for letter in line : image = self . get ( letter ) image = scale_image ( image , scale ) surf . blit ( image , ( cursor , y )) w = image . get_width () cursor += w + self . xpad * scale y += ( ysize + self . ypad ) * scale return cursor def get ( self , letter : str ) -> Surface : \"\"\" Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Args: letter: \"\"\" try : return self . letters [ letter ] except KeyError : return self . not_found def _align_cursor ( self , line : str , x : int , align : int , scale : int , wrap : int ) -> int : \"\"\" Used for left/right/centered text alignmnent \"\"\" match align : case - 1 | None : cursor = x case 0 : if not wrap : raise TextError ( \"Can't center text without specifying a wrap width.\" ) line_width = self . _printed_width ( line , scale ) slack = wrap - line_width cursor = x + slack // 2 case 1 : line_width = self . _printed_width ( line , scale ) cursor = x + wrap - line_width case _ : raise TextError ( f \"Bad alignment value: { align } \" ) return cursor def _wrap_words ( self , text : str , wrap : int , x : int = 0 , scale : int = 1 ) -> list [ str ]: \"\"\" Break one long line into multiple lines based on the wrap width. \"\"\" lines = [] line = \"\" for word in text . split ( \" \" ): new_line = f \" { line } { word } \" if line else word if self . _printed_width ( new_line , scale ) <= wrap : line = new_line else : lines . append ( line ) line = word lines . append ( line ) # last line return lines def _printed_width ( self , text : str , scale : int ) -> int : \"\"\" Calculate how wide a string of text will be when rendered. \"\"\" return sum (( self . get ( letter ) . get_width () + self . xpad ) * scale for letter in text ) def _trim_images ( self , images : list [ Surface ]) -> list [ Surface ]: \"\"\" Make a monospaced font non-monospaced \"\"\" trimmed = [] for image in images : x , _ , w , _ = image . get_bounding_rect () # trim x to bounding rect _ , y , _ , h = image . get_rect () # maintain original y position of character new = image . subsurface (( x , y , w , h )) trimmed . append ( new ) return trimmed","title":"Font"},{"location":"reference/text/font/#robingame.text.font.Font.__init__","text":"Loads the font from a spritesheet of letters using load_spritesheet . Parameters: filename ( str | Path ) \u2013 path to the spritesheet of letters image_size ( tuple [ int , int ] ) \u2013 the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters ( str ) \u2013 describes the order in which the characters appear in the spritesheet xpad ( int ) \u2013 extra x space between characters (in pixels). Can be negative ypad ( int ) \u2013 extra y space between characters (in pixels). Can be negative trim ( bool ) \u2013 if True , trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If False , leave the characters equal width (results in a monospaced font) space_width ( int ) \u2013 desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs ( dict ) \u2013 any extra kwargs will be passed on to load_spritesheet Example test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) robingame/text/font.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , filename : str | Path , image_size : tuple [ int , int ], letters : str , xpad : int = 0 , ypad : int = 0 , trim : bool = False , space_width : int = None , ** kwargs : dict , ): \"\"\" Loads the font from a spritesheet of letters using `load_spritesheet`. Args: filename: path to the spritesheet of letters image_size: the xy size of a character image in the spritesheet (we assume the characters are evenly spaced in the spritesheet) letters: describes the order in which the characters appear in the spritesheet xpad: extra x space between characters (in pixels). Can be negative ypad: extra y space between characters (in pixels). Can be negative trim: if `True`, trim any empty x space from the characters so that the width of each character depends on the letter (\"l\" will be narrower than \"m\"). If `False`, leave the characters equal width (results in a monospaced font) space_width: desired width of the space character (in pixels). If omitted, the space will be made as wide as a character kwargs: any extra kwargs will be passed on to `load_spritesheet` Example: ``` test_font = Font( filename=\"test_font.png\", image_size=(16, 16), letters=( string.ascii_uppercase + string.ascii_lowercase + r\"1234567890-=!@#$%^&*()_+[];',./{}|:<>?~`\" ), trim=True, xpad=1, space_width=8, ) ``` \"\"\" self . image_size = width , height = image_size self . xpad = xpad self . ypad = ypad self . letters = dict () self . letters [ \" \" ] = empty_image (( space_width or width , height )) self . not_found = Surface ( image_size ) self . not_found . fill ( Color ( \"red\" )) images = load_spritesheet ( filename , image_size = image_size , ** kwargs ) if trim : images = self . _trim_images ( images ) self . letters . update ({ letter : image for letter , image in zip ( letters , images )})","title":"__init__()"},{"location":"reference/text/font/#robingame.text.font.Font.get","text":"Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Parameters: letter ( str ) \u2013 robingame/text/font.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 def get ( self , letter : str ) -> Surface : \"\"\" Get the image associated with a letter. If this font does not have a character for the letter, return the error image ( usually a red rectangle) Args: letter: \"\"\" try : return self . letters [ letter ] except KeyError : return self . not_found","title":"get()"},{"location":"reference/text/font/#robingame.text.font.Font.render","text":"Render text onto a surface. Parameters: surf ( Surface ) \u2013 surface on which to render the text text ( str ) \u2013 the string of characters to render in this font x ( int ) \u2013 x-position on the surface y ( int ) \u2013 y-position on the surface scale ( int ) \u2013 factor by which to scale the text (1 = no scaling) wrap ( int ) \u2013 x width at which to wrap text align ( int ) \u2013 -1=left, 0=center, 1=right Example test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) robingame/text/font.py 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def render ( self , surf : Surface , text : str , x : int = 0 , y : int = 0 , scale : int = 1 , wrap : int = 0 , align : int = None , ) -> int : \"\"\" Render text onto a surface. Args: surf: surface on which to render the text text: the string of characters to render in this font x: x-position on the surface y: y-position on the surface scale: factor by which to scale the text (1 = no scaling) wrap: x width at which to wrap text align: -1=left, 0=center, 1=right Example: ``` test_font.render( surface, text=\"Hello world!\", scale=2, wrap=50, x=10, y=20, align=-1, ) ``` \"\"\" _ , ysize = self . image_size cursor = x for line in text . splitlines (): wrapped_lines = self . _wrap_words ( line , wrap , x , scale ) if wrap else [ line ] for line in wrapped_lines : cursor = self . _align_cursor ( line , x , align , scale , wrap ) for letter in line : image = self . get ( letter ) image = scale_image ( image , scale ) surf . blit ( image , ( cursor , y )) w = image . get_width () cursor += w + self . xpad * scale y += ( ysize + self . ypad ) * scale return cursor","title":"render()"}]}