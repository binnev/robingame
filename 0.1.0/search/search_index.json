{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Robingame docs Object-oriented tools for PyGame projects :)","title":"Robingame docs"},{"location":"#robingame-docs","text":"Object-oriented tools for PyGame projects :)","title":"Robingame docs"},{"location":"quickstart/","text":"Quick start import foo foo()","title":"Quick start"},{"location":"quickstart/#quick-start","text":"import foo foo()","title":"Quick start"},{"location":"reference/entity/","text":"Entity Bases: pygame . sprite . Sprite Finite State Machine: self.state is executed every tick self.tick is incremented every time the main game loop executes when self.state changes, self.tick is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: Entities can be added to Groups to create a hierarchical structure The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity Source code in robingame/objects/entity.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class Entity ( pygame . sprite . Sprite ): \"\"\" Finite State Machine: - `self.state` is executed every tick - `self.tick` is incremented every time the main game loop executes - when self.state changes, self.tick is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: - Entities can be added to Groups to create a hierarchical structure - The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: ``` Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity ``` \"\"\" _state : Callable = lambda * args , ** kwargs : None # default state: do nothing child_groups : list [ Group ] # groups of child Entities belonging to this entity tick : int = 0 # number of game loop iterations elapsed in the current state def __init__ ( self , groups : Iterable [ Group ] = ()): super () . __init__ ( * groups ) self . child_groups = [] def update ( self ): \"\"\" Update all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) def kill ( self ): \"\"\"Removes self from all groups it is a member of.\"\"\" for group in self . child_groups : group . kill () super () . kill () @property def state ( self ): \"\"\"Execute the current state function.\"\"\" return self . _state @state . setter def state ( self , new_state ): \"\"\" Reset self.tick when state changes so we know how long we've been in the current state. \"\"\" self . _state = new_state self . tick = 0 def __repr__ ( self ): \"\"\"The `_Sprite__g` is necessary because of name mangling in subclasses I think\"\"\" return f \"< { self . __class__ . __name__ } Entity(in { len ( self . _Sprite__g ) } groups)>\" state property writable Execute the current state function. __repr__ () The _Sprite__g is necessary because of name mangling in subclasses I think robingame/objects/entity.py 91 92 93 def __repr__ ( self ): \"\"\"The `_Sprite__g` is necessary because of name mangling in subclasses I think\"\"\" return f \"< { self . __class__ . __name__ } Entity(in { len ( self . _Sprite__g ) } groups)>\" draw ( surface , debug = False ) Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Parameters: surface ( Surface ) \u2013 the surface (usually the screen) on which to draw self debug ( bool ) \u2013 if True, draw extra stuff for debugging robingame/objects/entity.py 59 60 61 62 63 64 65 66 67 68 69 70 def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) kill () Removes self from all groups it is a member of. robingame/objects/entity.py 72 73 74 75 76 def kill ( self ): \"\"\"Removes self from all groups it is a member of.\"\"\" for group in self . child_groups : group . kill () super () . kill () update () Update all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. robingame/objects/entity.py 47 48 49 50 51 52 53 54 55 56 57 def update ( self ): \"\"\" Update all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state","title":"Entity"},{"location":"reference/entity/#entity","text":"Bases: pygame . sprite . Sprite Finite State Machine: self.state is executed every tick self.tick is incremented every time the main game loop executes when self.state changes, self.tick is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: Entities can be added to Groups to create a hierarchical structure The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity Source code in robingame/objects/entity.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class Entity ( pygame . sprite . Sprite ): \"\"\" Finite State Machine: - `self.state` is executed every tick - `self.tick` is incremented every time the main game loop executes - when self.state changes, self.tick is set to 0, so you can track how long the entity has been in its current state Hierarchical structure: - Entities can be added to Groups to create a hierarchical structure - The order of groups in the .child_groups attribute determines the draw order; it's basically the layers Example game structure: ``` Game: Entity \u2514\u2500\u2500 scenes: Group \u2514\u2500\u2500 MainMenu: Entity \u251c\u2500\u2500 buttons: Group \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u251c\u2500\u2500 Button: Entity \u2502 \u2514\u2500\u2500 Button: Entity \u2514\u2500\u2500 sliders: Group \u251c\u2500\u2500 Slider: Entity \u2514\u2500\u2500 Slider: Entity ``` \"\"\" _state : Callable = lambda * args , ** kwargs : None # default state: do nothing child_groups : list [ Group ] # groups of child Entities belonging to this entity tick : int = 0 # number of game loop iterations elapsed in the current state def __init__ ( self , groups : Iterable [ Group ] = ()): super () . __init__ ( * groups ) self . child_groups = [] def update ( self ): \"\"\" Update all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug ) def kill ( self ): \"\"\"Removes self from all groups it is a member of.\"\"\" for group in self . child_groups : group . kill () super () . kill () @property def state ( self ): \"\"\"Execute the current state function.\"\"\" return self . _state @state . setter def state ( self , new_state ): \"\"\" Reset self.tick when state changes so we know how long we've been in the current state. \"\"\" self . _state = new_state self . tick = 0 def __repr__ ( self ): \"\"\"The `_Sprite__g` is necessary because of name mangling in subclasses I think\"\"\" return f \"< { self . __class__ . __name__ } Entity(in { len ( self . _Sprite__g ) } groups)>\"","title":"Entity"},{"location":"reference/entity/#robingame.objects.entity.Entity.state","text":"Execute the current state function.","title":"state"},{"location":"reference/entity/#robingame.objects.entity.Entity.__repr__","text":"The _Sprite__g is necessary because of name mangling in subclasses I think robingame/objects/entity.py 91 92 93 def __repr__ ( self ): \"\"\"The `_Sprite__g` is necessary because of name mangling in subclasses I think\"\"\" return f \"< { self . __class__ . __name__ } Entity(in { len ( self . _Sprite__g ) } groups)>\"","title":"__repr__()"},{"location":"reference/entity/#robingame.objects.entity.Entity.draw","text":"Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Parameters: surface ( Surface ) \u2013 the surface (usually the screen) on which to draw self debug ( bool ) \u2013 if True, draw extra stuff for debugging robingame/objects/entity.py 59 60 61 62 63 64 65 66 67 68 69 70 def draw ( self , surface : Surface , debug : bool = False ): \"\"\" Draw all child groups. This allows the entire tree of objects to draw by only calling the .draw() method of the root object. Args: surface: the surface (usually the screen) on which to draw self debug: if True, draw extra stuff for debugging \"\"\" for group in self . child_groups : group . draw ( surface , debug )","title":"draw()"},{"location":"reference/entity/#robingame.objects.entity.Entity.kill","text":"Removes self from all groups it is a member of. robingame/objects/entity.py 72 73 74 75 76 def kill ( self ): \"\"\"Removes self from all groups it is a member of.\"\"\" for group in self . child_groups : group . kill () super () . kill ()","title":"kill()"},{"location":"reference/entity/#robingame.objects.entity.Entity.update","text":"Update all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. robingame/objects/entity.py 47 48 49 50 51 52 53 54 55 56 57 def update ( self ): \"\"\" Update all child groups. This allows the entire tree of objects to update by only calling the .update() method of the root object. Subclasses can override this method to provide subclass-specific behaviour. \"\"\" self . state () # execute current state function for group in self . child_groups : group . update () self . tick += 1 # increment tick to keep track of how long we've been in the current state","title":"update()"}]}